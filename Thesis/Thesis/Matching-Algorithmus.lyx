#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style german
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Umsetzung
\end_layout

\begin_layout Section
Ansätze
\end_layout

\begin_layout Standard
Im folgenden Abschnitt werden verschiedene Ansätze behandelt, welche im
 Laufe der Arbeit evaluiert wurden.
 Zudem werden die Stärken und Schwächen der Ansätze zu denen des ausgewählten
 Algorithmus betrachtet und bewertet.
\end_layout

\begin_layout Subsection
Iterative Closest Point
\end_layout

\begin_layout Standard
Der 
\emph on
Iterative Closest Point
\emph default
 Algorithmus (ICP) ist ein sehr bekannter und verbreiteter Algorithmus für
 
\emph on
Rigid Registration
\emph default
.
 Er funktioniert wie folgt: 
\end_layout

\begin_layout Standard
Zuerst werden die Transformationsparameter so initialisiert, dass die beiden
 Punktwolken keine zu großen Unterschiede aufweisen.
 Danach werden die Transformationsparameter (Rotation, Translation und Skalierun
g) auf eine Punktwolke angewandt, sodass nun für jeden Punkt aus der transformie
rten Punktwolke der dichteste Punkt aus der fixen Punktwolke bestimmt werden
 kann.
 Wenn die Zuordnung bestimmt wurde, kann nun über die Summe der Abstandsquadrate
 zwischen den Punkten ein Fehler zwischen den Punktwolken berechnet werden.
 Ist dieser Fehler klein genug ist die Registrierung abgeschlossen, ist
 er zu groß werden die Transformationsparameter anhand der gefundenen Zuordnung
 neu bestimmt und der Algorithmus wird iterativ wiederholt, bis er konvergiert.
\begin_inset Newline newline
\end_inset

ICP existiert schon recht lange, deswegen gibt es eine Vielzahl von Erweiterunge
n, wie z.B.
 EM-ICP, welches ICP durch den EM-Algorithmus erweitert.
 So existieren auch Varianten die ICP beschleunigen usw.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hier die aus den Quellen beschreiben
\end_layout

\end_inset

 
\begin_inset Newline newline
\end_inset

Der ICP Algorithmus ist auf Grund seiner einfachen Funktionsweise sehr performan
t und leicht zu verstehen.
 Außerdem lässt er sich wegen seines modularen Aufbaus sehr gut erweitern
 und verändern, was ihn gut anpassbar für viele Situationen macht.
 Er hat jedoch auch einige Nachteile, diese werden im folgenden erläutert.
 Die Punktwolken müssen initial bereits annähernd zueinander passen, da
 sonst nicht die optimale Lösung bestimmt werden kann.
 Außerdem sorgen fehlende Punkte in einer der Punktwolken für Probleme,
 da diese die Zuordnung verfälschen können und somit den berechneten Fehler.
\begin_inset Newline newline
\end_inset

Der ICP Algorithmus wurde aus folgenden Gründen nicht in dieser Arbeit verwendet
:
\end_layout

\begin_layout Enumerate
Die Rotation zwischen den beiden Punktwolken kann beliebig sein und ist
 vorher nicht bestimmbar
\end_layout

\begin_layout Enumerate
Es können mehrere Punkte in den Punktwolken fehlen, da diese recht viele
 Punkte enthalten können
\end_layout

\begin_layout Enumerate
Die Zuordnung von Punkten ist eindeutig (0 oder 1), was das erkennen von
 Fehlern oder das bestimmen einer Vertrauenswürdigkeit sehr schwer macht
\end_layout

\begin_layout Subsection
Subgraph Matching
\end_layout

\begin_layout Standard
Das Subgraph Matching ist ein weiterer Ansatz, um eine Zuordnung zwischen
 den Punktwolken wiederherzustellen.
 Hierfür würden die Punktwolken als zwei vollvermaschte Graphen betrachtet
 werden.
 Das Subgraph Matching auch Sub-Graph Isomorphismus Problem genannt basiert
 auf zwei gegebenen Graphen 
\begin_inset Formula $G$
\end_inset

 und 
\begin_inset Formula $H$
\end_inset

, wobei gezeigt werden soll das 
\begin_inset Formula $G$
\end_inset

 einen Subgraph isomorph zu 
\begin_inset Formula $H$
\end_inset

 enthält.
 Die Eigenschaft isomorph bedeutet das eine Bijektion zwischen den Kanten
 von 
\begin_inset Formula $G$
\end_inset

 und 
\begin_inset Formula $H$
\end_inset

 existiert, sodass zwei benachbarte Kanten in 
\begin_inset Formula $G$
\end_inset

 auch in 
\begin_inset Formula $H$
\end_inset

 benachbarten Kanten entsprechen.
 Für dieses Problem existieren bereits Algorithmen, welche es für große
 Graphen lösen können.[Cordello 2004] [Bonnici 2013]
\begin_inset Newline newline
\end_inset

Die Stärke dieses Ansatzes ist die Genauigkeit, da das finden eines Subgraphen
 eine eindeutige Zuordnung zur Folge hätte, welche je nach Größe des Subgraphs
 auch als dementsprechend sicher einzustufen wäre.
 Zusätzlich kann sich so jede beliebige Rotation zwischen den Punktwolken
 finden lassen, da die Zuordnung nur auf den Abständen zwischen den Punkten
 basiert.
\begin_inset Newline newline
\end_inset

Jedoch hat dieser Ansatz eine gravierende Schwäche für die zu bearbeitende
 Problemstellung, welche auch für den Verwurf des Ansatzes sorgte.
\begin_inset Newline newline
\end_inset

Das Graph Matching kann mit Ausreißern nicht arbeiten, da es nicht fehlende
 Punkte erkennen kann und ein vollvermaschter Graph sich negativ auf die
 Laufzeit auswirkt.
 Die Ausreißer bei diesem Problem können in AIS- sowie ARPA-Punktwolken
 existieren.
 In der AIS-Punktwolke existieren mehr Punkte als in der ARPA-Punktwolke,
 weil AIS mehr Reichweite als das Radar hat und AIS geographisch nicht durch
 verschiedenen Höhen beschränkt ist wie das Radar.
 Außerdem kann die ARPA-Punktwolke auch Punkte enthalten die in der AIS-Punktwol
ke fehlen.
 Dies ist möglich falls ein Schiff kein AIS sendet oder Radarschatten fälschlich
 für Schiffe gehalten werden.
 Zusätzlich ist der Ansatz sehr Laufzeit intensiv, da die beiden Graphen
 zuerst erstellt werden müssen, wofür die Distanz zwischen allen Punkten
 berechnet werden muss.
 
\end_layout

\begin_layout Subsection
Coherent Point Drift
\end_layout

\begin_layout Standard
Der in dieser Arbeit verwendete Algorithmus ist der Coherent Point Drift
 Algorithmus.
 Dieser wurde aus verschiedenen Punkten ausgewählt, welche im folgenden
 erläutert werden.
\end_layout

\begin_layout Standard
Der CPD kann mit verrauschten Daten arbeiten, da er eine 
\emph on
weiche 
\emph default
Zuordnung (Wert zwischen 0 und 1) berechnet anstatt einer eindeutigen Zuordnung
 wie der ICP Algorithmus.
 Durch diese 
\emph on
weiche
\emph default
 Zuordnung ist es auch möglich eine Aussage über die Vertrauenswürdigkeit
 eines Zuordnungspaares zu treffen.
 Dadurch könnte der errechnete Wert wie genau die Zuordnung gepasst hat,
 als Gewichtung genutzt werden.
\begin_inset Newline newline
\end_inset

Eine weitere wichtige Eigenschaft von CPD ist, dass es möglich ist Ausreißer
 in den Punktwolken zu erkennen und diese keinem Punkt zuzuordnen.
 Dies war in ICP und Subgraph Matching noch ein Problem.
\begin_inset Newline newline
\end_inset

Zusätzlich kann der CPD auch eine Rotation der Punktwolke erkennen was essentiel
l für die Bestimmung des Headings des Schiffes ist (siehe Programmablauf).
\begin_inset Newline newline
\end_inset

Es existiert ein Problem mit diesem Ansatz.
 Der CPD kann keine beliebige Rotation erkennen, dieses Problem lässt sich
 jedoch in vielen Point Set Registration Algorithmen finden.
 Die Lösung dieses Problems wird in 4.2.3 genauer erklärt.
 
\begin_inset Newline newline
\end_inset

In der folgenden Tabelle 1.1???? ist die Entscheidungsfindung nochmal tabelliert.
 Zu erkennen sind die einzelnen Stärken der Ansätze und welche Eigenschaften
 fehlen, um das hier betrachtete Problem effektiv zu lösen.
 GRAFIK STATT TABELLE?
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ICP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Subgraph Matching
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPD
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rauschen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rotation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ausreißer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
weiches Matching
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Vor- und Nachteile der Ansätze
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementierung
\end_layout

\begin_layout Subsection
Programmablauf
\end_layout

\begin_layout Standard
Das entstandene Softwaremodul umfasst verschiedene Abläufe, welche zum besseren
 Verständnis erläutert werden.
\end_layout

\begin_layout Standard
In Abbildung 3.1??? ist der Ablauf der Software anhand eines Aktivitätsdiagramms
 dargestellt, dieser wird im folgenden genauer erläutert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/User/Desktop/Repositorys/Thesis/Plannung/ProgrammAblauf.png
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Aktivitätsdiagramm des Softwaremoduls 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zuerst werden die benötigten Daten von der Brücke als NMEA-Nachrichten eingelese
n.
 Dies geschieht durch einen NMEA-Parser von Raytheon Anschütz, welcher in
 das Modul eingebunden ist.
\end_layout

\begin_layout Standard
Im folgenden wird ein Algorithmus ausgewählt, welcher passend zu den verfügbaren
 Daten den weiteren Ablauf bestimmt.
 Die folgenden Daten werden hier auf ihre Existenz geprüft:
\end_layout

\begin_layout Enumerate
AIS Daten umliegender Schiffe und AtoNs
\end_layout

\begin_layout Enumerate
Die Geschwindigkeit des eigenen Schiffes
\end_layout

\begin_layout Enumerate
Empfangene AIS-Daten von mindestens drei AtoNs
\begin_inset Newline newline
\end_inset

Anhand dieser Daten wird ein Algorithmus ausgewählt, welcher in der jeweiligen
 Situation das beste Ergebnis erzielt.
\end_layout

\begin_layout Standard
Der bestimmte Algorithmus gibt nun an, welche der drei Filter auf die Daten
 angewendet werden müssen, um die für den Algorithmus relevanten Daten zu
 extrahieren.
 Diese drei sind: das filtern nach den neuesten AIS und ARPA Daten der Schiffe,
 das filtern nach den AtoNs im AIS und das filtern nach ARPA Daten, welche
 keine Geschwindigkeit aufweisen.
\begin_inset Newline newline
\end_inset

Zusätzlich zu diesen drei Filtern werden die AIS-Daten mithilfe von Seekarten
 Informationen abgeglichen.
 Bei diesem Abgleich werden fehlende AtoNs im AIS durch AtoNs aus den Seekarten
 korrigiert.
 Dies ist möglich, da alle AtoNs in der Seekarte verzeichnet sind.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Satz vielleicht nochmal umschreiben
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nach der Anwendeung der Filter auf die Daten, wird der Zeitverzug der AIS-Daten
 korrigiert.
 Dieser Zeitverzug existiert, da AIS-Nachrichten in einer Frequenz zwischen
 3s bis 2min gesendet werden können.
 Die Sendezeit ist abhängig von der Geschwindigkeit und der Kursänderung
 des Schiffes.
 Die Radar Antenne, welche für die ARPA-Daten zuständig ist benötigt jedoch
 für eine volle Umdrehung bzw.
 für das erfassen aller umliegenden Schiffe nur ca.
 2s bis 4s.
 Dieser zeitliche Versatz zwischen den beiden Datensätzen hat einen großen
 Einfluss auf die Genauigkeit der Zuordnung des Algorithmus.
 
\end_layout

\begin_layout Standard
Im folgenden startet der spezifische Algorithmus, die einzelnen Komponenten
 des Algorithmus werden im Laufe der Arbeit genauer behandelt, so wird 
\emph on
AIS zum Koordinaten-Ursprung verschieben
\emph default
 in Unterabschnitt 4.2.2 behandelt und wie das initiale Heading den Algorithmus
 beeinflusst wird in 4.23 erklärt.
\begin_inset Newline newline
\end_inset

Das Ergebnis des Algorithmus ist die Zuordnung zwischen den Punkten und
 der Rotationsunterschied, welcher benötigt wurde um die Punktmengen ineinander
 zu überführen.
 Die Zuordnung wird für den in 4.3 erklärten Position-Fix Algorithmus benötigt
 und die Rotation, welche benötigt wird um beide Punktwolken einander zuzuordnen
 entspricht dem Heading des Eigenschiffes.
 Die Bestimmung des Headings auf diese Weise ist möglich, da die ARPA-Daten
 von der relativen Ausrichtung des Schiffes abhängen, die AIS-Daten jedoch
 nach Norden ausgerichtet sind.
 Somit entspricht eine Drehung der ARPA-Daten, bis sie mit den AIS-Daten
 übereinstimmen, dem Winkel zwischen der Ausrichtung des Schiffe und der
 Himmelsrichtung Norden.
 Dies ist der Winkel, in welchem das Heading eines Schiffes angegeben wird.
\end_layout

\begin_layout Standard
Mit den Ergebnissen des Coherent Point Drift Algorithmus kann nun der Position-F
ix die Eigenposition bestimmen (4.3) und diese als Positionsangabe über eine
 NMEA-Nachricht an die Brücke senden.
 Zusätzlich wird noch eine Visualisierung des Ergebnisses über die von Herrn
 André Becker entwickelte Netzwerkschnittstelle an die ECDIS gesendet.
\end_layout

\begin_layout Subsection
Ungenauigkeiten durch den Erdellipsoid
\end_layout

\begin_layout Standard
Der Coherent Point Drift Algorithmus basiert auf Koordinaten in kartesischer
 Form.
 In dieser Arbeit wurde dieser, auf geodätische Koordinaten angewendet.
 Wodurch einige Genauigkeitsprobleme entstanden, die im weiteren erläutert
 werden und eine Lösung präsentiert wird.
\end_layout

\begin_layout Standard
Das erste Problem beruht auf der Translation, welche der Algorithmus anwendet
 um die Distanz zwischen zwei Punktwolken zu minimieren.
 
\begin_inset Newline newline
\end_inset

Die Translation basiert auf dem Unterschied der Punktwolken in 
\begin_inset Formula $x$
\end_inset

 und 
\begin_inset Formula $y$
\end_inset

 Achse.
 Dies ist zwar korrekt in einem kartesischen Koordinatensystem, wo der Abstand
 zwischen zwei Punkten über die Euklidische Norm bestimmt werden kann, jedoch
 nicht wenn mit geodätische Koordinaten gearbeitet wird.
 Der Grund hierfür ist, dass der Abstand zwischen den Längengraden zwischen
 Nord- bzw.
 Südpol und dem Äquator sich je nach Position ändern.
 Als Folge hiervon ist es zwar möglich die Punktwolken zueinander zu bewegen,
 jedoch ist die Translation, welche der Algorithmus bestimmt, mit einem
 Fehler versehen.
 Diese Abweichungen die durch dieses Problem entstanden sind verhalten sich
 proportional zum Abstand der beiden Punktwolken.
 Der Abstand zwischen den Punktwolken kann beliebig groß sein, da die ARPA-Punkt
wolke ohne eine absolute Positionsangabe in Polarkoordinaten vorliegt und
 somit eine initial Position benötigt wird um aus dieser geodätische Koordinaten
 zu erstellen.
 
\end_layout

\begin_layout Standard
In der folgenden Tabelle wird gezeigt wie der Fehler sich mit steigender
 Translation verhält.
 Hierfür wurden die Distanzen auf dem Erdellipsoid zwischen zwei Punkten
 beobachtet, welche mittels einer Translation immer weiter von ihrer originalen
 Position verschoben wurden.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Translation (lat/lon)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(0/0)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(10/10)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(20/20)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(30/30)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(40/40)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(50/50)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Distanz (m)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24758,5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24683,9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24478,9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24164,8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
23775,7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
23355,8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Abweichung (m)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
74,5581
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
279,609
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
593,68
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
982,744
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1402,62
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Fehler durch Translation auf dem Erdellipsoid
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es ist deutlich zu erkennen, dass desto größter die Strecke wurde über welche
 die Punkte mittels der Translation verschoben wurden, desto größer wurde
 auch der Fehler in der Distanz zwischen diesen Punkten.
 Somit gilt es die Translation so klein wie möglich zu halten, damit dieser
 Fehler keine signifikanten Auswirkungen auf das Ergebnis hat.
\end_layout

\begin_layout Standard
Das zweite Problem entstand durch die Rotation, welche Teil des Algorithmus
 ist.
 Bei einer Rotation werden alle Punkte einer Punktwolke um den Ursprung
 des Koordinatensystems gedreht und erhalten somit eine neue Position.
 Durch das Rotieren einer kartesischen Punktwolke um den Ursprung ändern
 sich die Positionen der Punkte, jedoch nicht die Abstände zwischen den
 Punkten.
 Wenn man geodätische Koordinaten rotiert ändern sich ebenso die Positionen
 der Punkte, jedoch ändert sich hier auch der Abstand zwischen den Punkten
 auf Grund der Unterschiedlichen Abstände zwischen Längengraden.
 Die Abweichungen die durch dieses Problem entstanden sind, steigen mit
 dem Abstand zwischen den Punktwolken.
\end_layout

\begin_layout Standard
Die Lösung für das erste Problem (Translation), ist dass minimieren der
 initialen Abstände zwischen den Punktwolken.
 Die Translation die nun benötigt wird für das überführen der einen Punktwolke
 in die andere resultiert in einer kleinen Abweichung, welche in Tests maximal
 
\begin_inset Formula $7m$
\end_inset

 entsprach.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Muss das nochmal dokumentiert werden?
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Die Lösung für das zweite Problem (Rotation) ist, dass verschieben des Schwerpun
ktes der zu rotierenden Punktwolke in den Ursprung des Koordinatensystems.
 Eine Rotation dieser Punktwolke bewirkt nun das der Schwerpunkt seine Position
 nicht verändert, wodurch die Punkte der Punktwolke eine minimale Positionsänder
ung durch eine Rotation erfahren.
\end_layout

\begin_layout Standard
Somit ist die Lösung für diese Probleme die Translation beider Punktwolken
 auf den Ursprung des Koordinatensystems, um so die Ungenauigkeiten so gering
 wie möglich zu halten.
 Dies hat auch den Effekt das Fehler, welche durch das verwenden der euklidische
n Norm auf dem Erdellipsoid entstehen, geringer ausfallen, weil Längen-
 und Breitengrad im Ursprung des Koordinatensystems fast gleich lang sind.
\begin_inset Newline newline
\end_inset

Für die ARPA - Punktwolke ist dies trivial, da aufgrund der Radar Daten
 diese Punkte in Polarkoordinaten angegeben sind.
 
\begin_inset Newline newline
\end_inset

Die AIS - Punktwolke ist jedoch an ihre absolute Position gebunden, deswegen
 ist eine andere Methodik notwendig, um die Punktwolke, ohne Änderung der
 Abstände zwischen den Punkten, verschieben zu können.
 Die Methodik sieht das bestimmen des Schwerpunktes vor, zu welchem die
 Abstände und der Richtungswinkel von jedem Punkt bestimmt wird.
 Nun kann dieser Punkt in verschoben werden und mithilfe der Abstände und
 Richtungswinkel, lässt sich die Punktwolke korrekt wiederherstellen.
 Der zu bestimmende Punkt ist der Schwerpunkt der AIS-Punktwolke, welcher
 sich über das arithmetische Mittel bestimmen lässt, solange es sich um
 eine nicht gewichtete Punktwolke handelt.
 Nun wird die Distanz und der Winkel zwischen jedem Punkt der Punktwolke
 und dem Schwerpunkt der Wolke bestimmt und gespeichert.
 Für die Berechnung der Distanz und der Winkel zwischen den Punkten wird
 die Vincenty Formel verwendet, damit keine Fehler durch die Erdkrümmung
 entstehen.
 Nun liegt die AIS-Punktwolke theoretisch in Polarkoordinaten vor.
 Das macht es möglich sie ebenso wie die ARPA - Punktwolke an den Ursprung
 zu platzieren.
 
\end_layout

\begin_layout Standard
Nun sind optimale Bedingungen geschaffen um eine Zuordnung zwischen den
 Punktwolken durch den Coherent Point Drift Algorithmus zu bestimmen.
\end_layout

\begin_layout Subsection
Rotationsschwäche von Coherent Point Drift
\end_layout

\begin_layout Standard
Das erkennen von Rotation ist eine essentielle Eigenschaft, welche der Algorithm
us benötigt um die Punktwolken einander zuzuordnen und somit auch das Heading
 des Eigenschiffes zu bestimmen.
 Die Rotation kann jeden beliebigem gültigen Wert entsprechen, da die Drehung
 der ARPA Punktwolke abhängig vom Heading ist und die Drehung der AIS Punktwolke
 immer nach Norden ausgerichtet ist.
 Somit ist jeder Rotationswinkel eine mögliche Lösung und das Problem kann
 nicht vorher behandelt werden.
\end_layout

\begin_layout Standard
Bei Experimenten mit dem Coherent Point Drift ist jedoch aufgefallen, das
 dieser Rotation nur bis ca.
 
\begin_inset Formula $60°$
\end_inset

 erkennen kann.
 Bei Punktwolken, welche mehr als 
\begin_inset Formula $60°$
\end_inset

 Rotationsunterschied besitzen, findet der Algorithmus möglicherweise nur
 ein lokales Minima und gibt dies als Lösung zurück.
 Die Ergebnisse des Experiments sind in Abbildung
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abbildung
\end_layout

\end_inset

 ???? visualisiert.
 Diese Schwäche im erkennen der Rotation vom Coherent Point Drift Algorithmus
 wurde bereits in anderen Arbeiten festgestellt.
 HIER PAPER VERLINKEN.
 
\begin_inset Newline newline
\end_inset

In Tabelle 1.3??? wurden die Ergebnisse des CPD Algorithmus für verschiedene
 Rotationen bestimmt.
 Diese Messung wurde mit perfekten Daten ausgeführt, dass bedeutet das alle
 Punkte zugeordnet werden können, die Punkte perfekt aufeinander passen
 und das lediglich der Rotationswinkel der Punktwolken sie voneinander untersche
idet.
 Die Punkte der Punktwolke wurden zufällig anhand einer Normalverteilung
 erstellt und besteht aus 20 Punkten in geodätischen Koordinaten.
 Alle Angaben sind in Grad gegeben.
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rotationswinkel (°)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gefundenes Minima (°)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 - 70
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
80 - 140
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150 - 160
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
172
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
170 - 220
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
230
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
230 - 300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
282
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
310 - 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Bestimmte Rotation durch CPD an perfekten Daten
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es ist deutlich zu erkennen, dass der CPD Algorithmus ab einem bestimmten
 Rotationswinkel, die korrekte Rotation nicht mehr findet und in einem lokalen
 Minimum terminiert.
 In den Testdaten von Tabelle 1.2??? werden fünf verschiedene Minima gefunden,
 je nach Rotation der Punktwolke.
 
\end_layout

\begin_layout Standard
Für dieses Problem wurde eine Lösung entwickelt, um die korrekte Rotation,
 sowie die korrekte Zuordnung zu bestimmen.
 
\end_layout

\begin_layout Standard
Hierfür wird der Algorithmus mehrfach ausgeführt, wobei nach jeder Ausführung
 die ARPA-Punktwolke rotiert wird und die Ergebnisse gespeichert werden.
 Für die kontinuierliche Rotation wurden 
\begin_inset Formula $45°$
\end_inset

 gewählt.
 Es wurden 
\begin_inset Formula $45°$
\end_inset

 gewählt, weil 
\begin_inset Formula $45$
\end_inset

 der nächste ganzzahlige Teiler von 
\begin_inset Formula $360$
\end_inset

 ist und welcher kleiner als 
\begin_inset Formula $52$
\end_inset

 ist.
 Die 
\begin_inset Formula $52°$
\end_inset

 ist der kleinste Raum für das Erkennen der Rotation durch den CPD unter
 real nahen Daten.
 Die Rotation der ARPA-Punktwolke ist sehr simple, da sie bereits in Polarkoordi
naten vorliegt.
 Nachdem der Algorithmus 8 mal ausgeführt wurde (
\begin_inset Formula $\frac{360}{45}=8$
\end_inset

) werden die Ergebnisse verglichen.
 Hierbei wird das Ergebnis mit dem geringsten Fehler zwischen den Punkten
 ausgewählt, da so das globale Optimum gefunden wird.
\begin_inset Newline newline
\end_inset

Diese Lösung hat natürlich einen großen Nachteil, welcher die Performanz
 des Algorithmus ist.
 Der Algorithmus muss acht mal gestartet werden um ein korrektes Ergebnis
 zu produzieren.
 Die achtfache Ausführung ist jedoch nur beim initialen Ausführen des Softwaremo
duls nötig, weil nach dem ersten Durchlauf des Softwaremoduls ein Heading
 an die Brücke gesendet wird, welches beim nächsten Aufrufen des Algorithmus
 mit gesendet wird und somit ein initiales Heading existiert.
 Wenn ein Heading mit gesendet wird muss der Algorithmus nur einmal ausgeführt
 werden, weil die ARPA-Punktwolke nur um den Wert des negativen Headings
 gedreht werden muss und dadurch die Punktwolken eine Ähnliche Rotation
 aufweisen sollten.
\end_layout

\begin_layout Section
Position-Fix
\end_layout

\begin_layout Standard
Der folgenden Abschnitt beschreibt die Berechnung der Eigenposition und
 des Sicherheitsbereichs, welche aus der Zuordnung und dem bestimmten Heading
 des CPD möglich ist.
\end_layout

\begin_layout Subsection
Bestimmung der Eigenposition
\end_layout

\begin_layout Standard
Mit dem Ergebnis des Coherent Point Drift Algorithmus können ARPA - Punkte
 auf ihre zugehörigen AIS - Punkte zugeordnet werden.
 Dadurch ist nun bekannt wo dieser Punkt absolut auf der Karte liegt (AIS-Daten)
 und wie er relativ zu der Schiffseigenposition liegt (ARPA-Daten).
 Durch diese beiden Daten ist es möglich die Schiffseigenposition für jedes
 Paar zugeordneter Punkte zu berechnen.
\begin_inset Newline newline
\end_inset

Damit diese Rückrechnung auf die Eigenposition möglich ist, muss zuerst
 das relative Bearing aus den ARPA - Daten in 
\emph on
true 
\emph default
Bearing umgerechnet werden.
 Als 
\emph on
True
\emph default
 Bearing wird das Bearing bezeichnet, welches relativ zur Nord-Richtung
 angegeben wird.
 Diese Umrechnung ist möglich, da der CPD-Algorithmus auch das Heading des
 Schiffes bestimmt.
 Das Heading des Schiffes ist relativ zur Nord-Richtung und bietet somit
 die Möglichkeit über folgende Formel eine relative Bearing Angabe in 
\emph on
True 
\emph default
Bearing umzurechnen:
\end_layout

\begin_layout Standard
\begin_inset Formula $b_{true}:$
\end_inset

 
\emph on
True 
\emph default
Bearing
\end_layout

\begin_layout Standard
\begin_inset Formula $b_{rel}:$
\end_inset

 Relatives Bearing
\end_layout

\begin_layout Standard
\begin_inset Formula $h:$
\end_inset

 Heading des Eigenschiffes
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
b_{true} & = & (b_{rel}-h)\quad mod\:360
\end{eqnarray*}

\end_inset


\begin_inset Newline newline
\end_inset

Nun kann von jedem Datenpaar eine individuelle Eigenposition bestimmt werden.
 Dies basiert auf der Lösung der 1.
 geodätischen Hauptaufgabe, diese ist das berechnen eines Punktes mit einem
 Startpunkt, einer Richtung und einer Distanz.
 Der Startpunkt sind die AIS Koordinaten, die Richtung ist das invertierte
 
\emph on
true 
\emph default
Bearing
\begin_inset Note Note
status open

\begin_layout Plain Layout
gibt es hierfür nicht eine mathematische Bezeichnung?
\end_layout

\end_inset

 und die Distanz kann aus den ARPA - Daten entnommen werden.
 Die Lösung der 1.
 geodätischen Hauptaufgabe lässt sich mithilfe der Vincenty Formel bestimmen.
 
\begin_inset Newline newline
\end_inset

Nachdem dies für jedes Datenpaar wiederholt wurde, existiert eine Punktwolke,
 welche die individuellen Eigenpositionen enthält.
 Zur Bestimmung der Eigenposition wird das arithmetische Mittel über diese
 Punktwolke gebildet.
 Falls die einzelnen Punkte vorher eine Gewichtung besitzen, zur Indizierung
 einer höheren Vertrauenswürdigkeit, kann hier auch das gewichtete arithmetische
 Mittel angewendet werden.
\begin_inset Newline newline
\end_inset

Die Auswirkung für die Verwendung eines gewichteten Arithmetischen Mittels
 anstatt des normalen arithmetischen Mittels ist in Abbildung 1.2??? zu erkennen.
 In der Abbildung haben die Punkte 6 - 10 eine höhere Gewichtung als die
 Punkte 1 - 4, was dafür sorgt, dass diese beim gewichteten Arithmetischen
 Mittel stärker berücksichtigt werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/jknopp/Desktop/Repositorys/Thesis/Thesis/Grafiken/Mittelwerte.PNG

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Arithmetisches Mittel der individuell zurückgerechneten Eigenpositionen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Abbildung zeigt wie stark die Genauigkeit der Positionsbestimmung erhöht
 werden kann, falls es möglich ist eine Aussage über die Genauigkeit oder
 die Vertrauenswürdigkeit der einzelnen Punkte treffen zu können.
 Das wäre möglich über das Unterscheiden von Schiffen und AtoNs oder einer
 manuellen Eingabe.
\end_layout

\begin_layout Subsection
Bestimmung der Sicherheit der Eigenposition und Eliminierung von Ausreißern
\end_layout

\begin_layout Standard
Die Bestimmung der Eigenposition erfolgt über das arithmetische Mittel,
 dieses ist jedoch anfällig für Ausreißer in der Punktwolke.
 Zusätzlich ist es notwendig die bestimmte Eigenposition mit einer Sicherheit
 bzw.
 eines Sicherheitsbereichs angeben zu können.
\end_layout

\begin_layout Standard
Durch die Anfälligkeit des arithmetischen Mittels auf Ausreißer, ist es
 notwendig diese zu bestimmen und in gravierenden Fällen zu eliminieren.
 Dies kann jedoch nur angewendet werden, wenn genügend Punkte in der Punktwolke
 existieren, da sonst Ausreißer nicht eindeutig klassifiziert werden können.
\begin_inset Newline newline
\end_inset

Zur Erkennung der Ausreißer wird die Mahalanobis Distanz verwendet.
 Die Mahalanobis Distanz ist ein Abstandsmaß, welche angibt wie weit ein
 Punkt von der Verteilung einer Punktwolke abweicht.
 Das Ergebnis der Mahalanobis Distanz wird in Standardnormalabweichungen
 angegeben.
 Die Mahalanobis Distanz ist wie folgt definiert: 
\end_layout

\begin_layout Standard
\begin_inset Formula $\vec{X_{i}}=\begin{pmatrix}lat_{i}\\
lon_{i}
\end{pmatrix}:$
\end_inset

 eine Zufallsvariable, welche die zurückgerechnete Position eines Datenpaars
 beschreibt.
 (
\begin_inset Formula $lat$
\end_inset

 ist der Breitengrad und 
\begin_inset Formula $lon$
\end_inset

 der Längengrad des Punktes)
\end_layout

\begin_layout Standard
\begin_inset Formula $\vec{\mu}=\begin{pmatrix}\mu_{lat}\\
\mu_{lon}
\end{pmatrix}:$
\end_inset

 Das arithmetische Mittel der Punktwolke
\end_layout

\begin_layout Standard
\begin_inset Formula $\Sigma:$
\end_inset

 Die Kovarianzmatrix der Punktwolke für welche gilt 
\begin_inset Formula $det(\Sigma)\neq0$
\end_inset


\end_layout

\begin_layout Standard
Mahalanobis-Distanz:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d(\vec{X},\vec{\mu})=\sqrt{(\vec{X}-\vec{\mu})^{T}\cdot\Sigma^{-1}\cdot(\vec{X}-\vec{\mu})}
\]

\end_inset


\begin_inset Newline newline
\end_inset

zur Berechnung der Mahalanobis Distanz wird nun das arithmetische Mittel
 und die Kovarianzmatrix bestimmt, jedoch ohne einbeziehen des Punktes zu
 welchem die Mahalanobis Distanz bestimmt werden soll, da sonst das Ergebnis
 verfälscht wird.
 Nachdem dies für jeden individuelle Eigenposition berechnet wurde ist es
 möglich Punkte zu entfernen, welche außerhalb einer bestimmten Prozentzahl
 der Verteilung liegen.
 Für diese Prozentzahl wurde 
\begin_inset Formula $99,865\%$
\end_inset

 gewählt, das entspricht einem Z-Wert der Standardnormalverteilung von 
\begin_inset Formula $3$
\end_inset

.
 Somit werden Punkte entfernt die Außerhalb von 
\begin_inset Formula $99.865\%$
\end_inset

 der Verteilung liegen.
\begin_inset Newline newline
\end_inset

Nachdem die Ausreißer entfernt wurden ist es wichtig die Genauigkeit des
 Ergebnisses angeben zu können.
 Hierfür wurde sich entschieden einen Sicherheitsbereich zu bestimmen, durch
 welchen eine prozentuale Sicherheit gegeben werden kann, wie wahrscheinlich
 es ist sich in diesem Bereich zu befinden.
 Dieser Sicherheitsbereich wird mithilfe der Mahalanobis Distanz bestimmt.
 Man setzt die Mahalanobis Distanz auf einen festen Wert, wie z.B.
 
\begin_inset Formula $2,33$
\end_inset

 was ca.
 
\begin_inset Formula $99\%$
\end_inset

 Sicherheit entspricht.
 Nun kann durch einsetzen des arithmetischen Mittels und der Kovarianzmatrix
 eine Menge an Punkten bestimmt werden, welche diese Mahalanobis Distanz
 haben.
 Die Form der Punkte entspricht einer Ellipse, welche der Sicherheitsbereich
 ist.
 Eine Visualisierung dieses Ablaufs ist in Abbildung???? zu erkennen.
 Die roten Punkte sind zurückgerechnete Eigenpositionen, wobei 10 ein Ausreißer
 ist, welcher das Resultat einer falschen Zuordnung sein könnte.
 Die blauen Ellipsen indizieren die Standardabweichungen vom Faktor 0,5
 bis 2,0 von innen nach außen.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Sicherheitsbereich über Standardabweichung? eher schlecht wegen der Abweichung,
 ist aktuell jedoch so im Algorithmus umgesetzt.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/jknopp/Desktop/Repositorys/Thesis/Thesis/Grafiken/OutlierRemoval.PNG

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Eliminierung von Ausreißern und Darstellung des Sicherheitsbereichs
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es ist klar zu erkennen wie groß die Auswirkung eines Ausreißers auf die
 Eigenposition und den Sicherheitsbereich ist.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hier noch weiter schreiben
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Erstellung des Ergebnisses
\end_layout

\begin_layout Standard
Nach dem Position-Fix Algorithmus wurden alle benötigten Daten berechnet
 um die Eigenposition, das Heading und eine geeignete Visualisierung darzustelle
n.
 Die Eigenposition und das Heading werden als NMEA-Nachricht an die Brücke
 gesendet, da ihre Daten so intern wie die Daten eines Sensors behandelt
 werden und dadurch eine Integritätsprüfung im Vergleich zu den anderen
 Sensoren möglich ist.
 Die Visualisierung und zusätzliche Daten, wie der Sicherheitsbereich, werden
 über die Netzwerkschnittstelle von Herrn André Becker an die ECDIS übermittelt.
 Die Visualisierung ist eine SVG-Grafik, welche beispielhaft in Abbildung
 ???
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abbildung
\end_layout

\end_inset

 abgebildet ist.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hier Erklärung zu der Visualisierung noch einfügen
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Visualisierung zur Anzeige des Ergebnisses auf der Seekarte
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
