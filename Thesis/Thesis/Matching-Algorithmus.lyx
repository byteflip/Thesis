#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style german
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Umsetzung
\end_layout

\begin_layout Section
Ansätze
\end_layout

\begin_layout Subsection
Iterative Closest Point
\end_layout

\begin_layout Standard
Der Iterative Closest Point Algorithmus (ICP) ist ein sehr bekannter und
 verbreiteter Algorithmus für Rigid Registration.
 Er funktioniert wie folgt: 
\end_layout

\begin_layout Standard
Zuerst werden die Transformationsparameter so initialisiert, dass die beiden
 Punktwolken keine zu großen Unterschiede aufweisen.
 Danach werden die Transformationsparameter (Rotation, Translation und Skalierun
g) auf eine Punktwolke angewandt, sodass nun für jeden Punkt aus der transformie
rten Punktwolke der dichteste Punkt aus er fixen Punktwolke bestimmt werden
 kann.
 Wenn die Zuordnung bestimmt wurde kann nun über die Summe der Abstandsquadrate
 zwischen den Punkten ein Fehler zwischen den Punktwolken berechnet werden.
 Ist dieser Fehler klein genug ist die Registrierung abgeschlossen, ist
 er zu groß werden die Transformationsparameter anhand der gefundenen Zuordnung
 neu bestimmt und der Algorithmus wird iterativ wiederholt bis er konvergiert.
\begin_inset Newline newline
\end_inset

ICP existiert schon recht lange, deswegen gibt es eine Vielzahl von Erweiterunge
n, wie z.B.
 EM-ICP, welches ICP durch den EM-Algorihtmus erweitert.
 So existieren auch Varianten die ICP beschleunigen usw.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hier die aus den Quellen beschreiben
\end_layout

\end_inset

 
\begin_inset Newline newline
\end_inset

Der ICP Algorithmus ist auf Grund seiner einfachen Funktionsweise sehr Performan
t und leicht zu verstehen.
 Außerdem lässt er sich wegen seines modularem Aufbaus sehr gut erweitern
 und verändern, was ihn gut anpassbar für viele Situationen macht.
 Er hat jedoch auch Nachteile in seiner nativen Form.
 Die Punktwolken müssen initial bereits annähernd zueinander passen, da
 ICP nicht die richtige Lösung bestimmen kann.
 Außerdem sorgen fehlende Punkte in einer der Punktwolken für Probleme,
 da dies den berechneten Fehler verfälscht.
\begin_inset Newline newline
\end_inset

Der ICP Algorithmus wurde aus folgenden Gründen nicht in dieser Arbeit verwendet
:
\end_layout

\begin_layout Enumerate
Die Rotation zwischen den beiden Punktwolken kann beliebig sein und ist
 vorher nicht bestimmbar
\end_layout

\begin_layout Enumerate
Es können mehrere Punkte in den Punktwolken fehlen, da diese recht viele
 Punkte enthalten können
\end_layout

\begin_layout Enumerate
Die Zuordnung von Punkten ist eindeutig (0 oder 1), was das erkennen von
 Fehlern oder das bestimmen einer Vertrauenswürdigkeit sehr schwer macht
\end_layout

\begin_layout Subsection
Graph-Matching
\end_layout

\begin_layout Standard
-Allgemeine Beschreibung
\end_layout

\begin_layout Standard
- finden von Subgraphen
\end_layout

\begin_layout Standard
- Funktionsweise kurz beschreiben
\end_layout

\begin_layout Standard
- Stärken: schnell und genau
\end_layout

\begin_layout Standard
- Schwächen: outlier können nicht gefunden werden => falsches Ergebnis
\end_layout

\begin_layout Standard
- Grafik? (wenn Platz ist ja)
\end_layout

\begin_layout Subsection
Coherent Point Drift
\end_layout

\begin_layout Standard
-Einleitung passend zu Grundlagen
\end_layout

\begin_layout Standard
- Begründung warum CPD verwendet wurde:
\end_layout

\begin_layout Standard
- outlier erkennen
\end_layout

\begin_layout Standard
- noise Data
\end_layout

\begin_layout Standard
- soft matching(0.0 - 0.5 - 1.0)? => Falsche matchings können besser erkannt
 werden
\end_layout

\begin_layout Standard
- Performanz Vergleich? (Wieder finden im Paper im Vergleich zu ICP)
\end_layout

\begin_layout Section
Implementierung
\end_layout

\begin_layout Subsection
Programmablauf
\end_layout

\begin_layout Standard
Das entstandene Softwaremodul umfasst verschiedene Abläufe, welche zum besseren
 Verständnis im folgenden erläutert werden.
\end_layout

\begin_layout Standard
In Abbildung 3.1??? ist der Ablauf der Software anhand eines Aktivitätsdiagramms
 dargestellt, dieser wird im folgenden genauer erläutert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/User/Desktop/Repositorys/Thesis/Plannung/ProgrammAblauf.png
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Aktivitätsdiagramm des Softwaremoduls 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zuerst werden die benötigten Daten von der Brücke als NMEA-Nachrichten eingelese
n und in Objekte übersetzt.
 Dies geschieht durch einen NMEA-Parser von Raytheon Anschütz, welcher in
 das Modul eingebunden ist.
\end_layout

\begin_layout Standard
Im folgenden wird ein Algorithmus ausgewählt, welcher passend zu den verfügbaren
 Daten den weiteren Ablauf bestimmt.
 Die hierfür geprüften Daten sind:
\end_layout

\begin_layout Enumerate
AIS Daten umliegender Schiffe und AtoNs
\end_layout

\begin_layout Enumerate
Die Geschwindigkeit des eigenen Schiffes
\end_layout

\begin_layout Enumerate
Empfangene AIS-Daten von mindestens drei AtoNs
\begin_inset Newline newline
\end_inset

Anhand dieser Daten wird ein Algorithmus ausgewählt, welcher in der jeweiligen
 Situation das beste Ergebnis erzielt.
\end_layout

\begin_layout Standard
Der vorher bestimmte Algorithmus gibt nun an welche der drei Filter auf
 die Daten angewendet werden müssen, um die für den Algorithmus relevanten
 Daten zu extrahieren.
 Diese drei sind: das filtern nach den neuesten AIS und ARPA Daten der Schiffe,
 das filtern nach den AtoNs im AIS und das filtern nach ARPA Daten, welche
 keine Geschwindigkeit aufweisen.
\begin_inset Newline newline
\end_inset

Zusätzlich zu diesen drei Filtern werden die AIS-Daten mithilfe von Seekarten
 Informationen abgeglichen.
 Falls AtoNs nicht vom AIS erfasst wurden, werden sie nun ergänzt.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Satz vielleicht nochmal umschreiben
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nachdem anwenden der Filter wird der Zeitverzug der AIS-Daten korrigiert.
 Dieser Zeitverzug existiert, da AIS-Nachrichten in einer Frequenz von 3s
 bis 2min gesendet werden können.
 Die Radar Antenne, welche für die ARPA-Daten zuständig ist benötigt jedoch
 für eine volle Umdrehung bzw.
 für das erfassen aller umliegenden Schiffe nur ca.
 2s bis 4s.
 Dieser zeitliche Versatz zwischen den beiden Datensätzen hat einen großen
 Einfluss auf die Genauigkeit der Zuordnung des Algorithmus.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Tabelle hier einfügen und nochmal erklären
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Genauigkeitssteigerung durch Korrektur des Zeitverzugs
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im folgenden startet der spezifische Algorithmus, die einzelnen Komponenten
 des Algorithmus werden im Laufe der Arbeit genauer behandelt, so wird 
\emph on
AIS zum Koordinaten-Ursprung verschieben
\emph default
 in Unterabschnitt 4.2.2 behandelt und wie das initiale Heading den Algorithmus
 beeinflusst wird in 4.23 erklärt.
\begin_inset Newline newline
\end_inset

Das Ergebnis des Algorithmus ist die Zuordnung zwischen den Punkten und
 der Rotationsunterschied, welcher benötigt wurde um die Punktmengen ineinander
 zu überführen.
 Die Zuordnung wird für den in 4.3 erklärten Position-Fix Algorithmus benötigt
 und die Rotation, welche benötigt wird um beide Punktwolken einander zuzuordnen
 entspricht dem Heading des Eigenschiffes.
 Das Heading auf diese Weise zu bestimmen ist möglich, da die ARPA-Daten
 von der relativen Ausrichtung des Schiffes abhängen, die AIS-Daten jedoch
 nach Norden ausgerichtet sind.
 Somit entspricht eine Drehung der ARPA-Daten, bis sie mit den AIS-Daten
 übereinstimmen, dem Winkel zwischen der Ausrichtung des Schiffe und der
 Himmelsrichtung Norden.
 Dies ist der Winkel, in welchem das Heading eines Schiffes angegeben wird.
\end_layout

\begin_layout Standard
Mit den Ergebnissen des Coherent Point Drift Algorithmus kann nun der Position-F
ix die Eigenposition bestimmen (4.3) und diese als Positionsangabe über eine
 NMEA-Nachricht an die Brücke senden.
 Zusätzlich wird noch eine Visualisierung des Ergebnisses über die von Herrn
 André Becker entwickelte Netzwerkschnittstelle an die ECDIS gesendet.
\end_layout

\begin_layout Subsection
Ungenauigkeiten durch den Erdellipsoid
\end_layout

\begin_layout Standard
Der Coherent Point Drift Algorithmus basiert auf Koordinaten in kartesischer
 Form.
 In dieser Arbeit wurde dieser, auf geodätische Koordinaten angewendet.
 Wodurch einige Genauigkeitsprobleme entstanden, die im weiteren erläutert
 werden und eine Lösung präsentiert wird.
\end_layout

\begin_layout Standard
Das erste Problem beruht auf der Translation, welche der Algorithmus anwendet
 um die Distanz zwischen zwei Punktwolken zu minimieren.
 
\begin_inset Newline newline
\end_inset

Die Translation basiert auf dem Unterschied der Punktwolken in 
\begin_inset Formula $x$
\end_inset

 und 
\begin_inset Formula $y$
\end_inset

 Achse.
 Dies ist zwar korrekt in einem kartesischen Koordinatensystem, wo der Abstand
 zwischen zwei Punkten über die Euklidische Norm bestimmt werden kann, jedoch
 nicht wenn mit geodätische Koordinaten gearbeitet wird.
 Der Grund hierfür ist, dass der Abstand zwischen den Längengraden zwischen
 Nord- bzw.
 Südpol und dem Äquator sich je nach Position ändern.
 Als Folge hiervon ist es zwar möglich die Punktwolken zueinander zu bewegen,
 jedoch ist die Translation, welche der Algorithmus bestimmt, mit einem
 Fehler versehen.
 Diese Abweichungen die durch dieses Problem entstanden sind verhalten sich
 proportional zum Abstand der beiden Punktwolken (siehe Abbildung/Tabelle
 ???).
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abbildung bzw Tabelle ergänzen
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das zweite Problem entstand durch die Rotation, welche Teil des Algorithmus
 ist.
 Bei einer Rotation werden alle Punkte einer Punktwolke um den Ursprung
 des Koordinatensystems gedreht und erhalten somit eine neue Position.
 Durch das Rotieren einer kartesischen Punktwolke um den Ursprung ändern
 sich die Positionen der Punkte, jedoch nicht die Abstände zwischen den
 Punkten.
 Wenn man geodätische Koordinaten rotiert ändern sich ebenso die Positionen
 der Punkte, jedoch ändert sich hier auch der Abstand zwischen den Punkten
 auf Grund der Unterschiedlichen Abstände zwischen Längengraden.
 Die Abweichungen die durch dieses Problem entstanden sind verhalten sich
 proportional zu der Verdrehung zwischen den Punktwolken und proportional
 zum Abstand zwischen Punktwolke und Ursprung.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Proportional? eher exponential oder?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Lösung für das erste Problem (Translation), ist dass minimieren der
 initialen Abstände zwischen den Punktwolken.
 Die Translation die nun benötigt wird für das überführen der einen Punktwolke
 in die andere ist so gering, dass der Fehler der durch die Erdkrümmung
 entsteht vernachlässigbar ist.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Messung im Anhang?
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Die Lösung für das zweite Problem (Rotation) ist, dass verschieben des Schwerpun
ktes der zu rotierenden Punktwolke in den Ursprung des Koordinatensystems.
 Eine Rotation dieser Punktwolke bewirkt nun das der Schwerpunkt seine Position
 nicht verändert, wodurch die Punkte der Punktwolke eine minimale Positionsänder
ung durch eine Rotation erfahren.
\end_layout

\begin_layout Standard
Somit ist die Lösung für diese Probleme die Translation beider Punktwolken
 auf den Ursprung des Koordinatensystems, um so die Ungenauigkeiten so gering
 wie möglich zu halten.
 Dies hat auch den Effekt das Fehler, welche durch das verwenden der euklidische
n Norm auf dem Erdellipsoid entstehen, geringer ausfallen, weil Längen-
 und Breitengrad im Ursprung des Koordinatensystems fast gleich lang sind.
\begin_inset Newline newline
\end_inset

Für die ARPA - Punktwolke ist dies trivial, da aufgrund der Radar Daten
 diese Punkte in Polarkoordinaten angegeben sind, was es leicht macht diese
 zu auf einen bestimmten Punkt zu verschieben.
 
\begin_inset Newline newline
\end_inset

Die AIS - Punktwolke ist jedoch an ihre absolute Position gebunden, deswegen
 ist eine andere Methodik notwendig um die Originale Punktwolke an den Ursprung
 verschieben zu können.
 Hierfür wird der Schwerpunkt der AIS - Punktwolke bestimmt, da diese aus
 nicht gewichteten Punkten besteht ist dieser äquivalent zum arithmetischen
 Mittel der Punktwolke.
 Nun wird die Distanz und der Winkel zwischen jedem Punkt der Punktwolke
 und dem arithmetischem Mittel bestimmt und gespeichert.
 Für die Berechnung der Distanz und der Winkel zwischen den Punkten wird
 die Vincenty Formel verwendet, damit keine Fehler durch die Erdkrümmung
 entstehen.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
inverse oder direct?
\end_layout

\end_inset

 Nun liegt die AIS - Punktwolke in Polarkoordinaten vor.
 Das macht es möglich sie ebenso wie die ARPA - Punktwolke an den Ursprung
 zu platzieren.
 
\end_layout

\begin_layout Standard
Nun sind optimale Bedingungen geschaffen um eine Zuordnung zwischen den
 Punktwolken durch den Coherent Point Drift Algorithmus zu bestimmen.
\end_layout

\begin_layout Subsection
Rotationsschwäche von Coherent Point Drift
\end_layout

\begin_layout Standard
Das erkennen von Rotation ist eine essentielle Eigenschaft, welche der Algorithm
us benötigt um die Punktwolken einander zuzuordnen und somit auch das Heading
 des Eigenschiffes zu bestimmen.
 Die Rotation kann jeden beliebigem gültigen Wert entsprechen, da die Drehung
 der ARPA Punktwolke abhängig vom Heading ist und die Drehung der AIS Punktwolke
 immer nach Norden ausgerichtet ist.
 Somit ist jeder Rotationswinkel eine mögliche Lösung und das Problem kann
 nicht vorher behandelt werden.
\end_layout

\begin_layout Standard
Bei Experimenten mit dem Coherent Point Drift ist jedoch aufgefallen, das
 dieser Rotation nur bis ca.
 
\begin_inset Formula $60°$
\end_inset

 erkennen kann.
 Bei Punktwolken, welche mehr als 
\begin_inset Formula $60°$
\end_inset

 Rotationsunterschied besitzen, findet der Algorithmus nur ein lokales Minima
 und gibt dies als Lösung zurück.
 Die Ergebnisse des Experiments sind in Abbildung
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abbildung
\end_layout

\end_inset

 ???? visualisiert.
 Diese Schwäche im erkennen der Rotation vom Coherent Point Drift Algorithmus
 wurde bereits in anderen Arbeiten festgestellt.
 HIER PAPER VERLINKEN.
 
\begin_inset Newline newline
\end_inset

Für dieses Problem wurde eine Lösung entwickelt, mit welcher die korrekte
 Rotation, sowie die korrekte Zuordnung bestimmt werden können.
 
\end_layout

\begin_layout Standard
Hierfür wird der Algorithmus mehrfach ausgeführt ,wobei nach jeder Ausführung
 die ARPA-Punktwolke um 
\begin_inset Formula $45°$
\end_inset

 rotiert wird und die Ergebnisse gespeichert werden.
 Die Rotation der ARPA-Punktwolke ist sehr simple, da sie bereits in Polarkoordi
naten vorliegt.
 Nachdem der Algorithmus 8 mal ausgeführt wurde (
\begin_inset Formula $\frac{360}{45}=8$
\end_inset

) werden die Ergebnisse verglichen.
 Hierbei wird das Ergebnis mit dem geringsten Fehler zwischen den Punkten
 ausgewählt, da dieses das globale Optimum indiziert.
 Bei Tests mit diesem Ansatz wurde unter verschiedenen Bedingungen immer
 der korrekte Rotationswinkel und die richtige Zuordnung gefunden.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abbildung/Tabelle
\end_layout

\end_inset

 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Erklären das hierdurch eine weitere Prüfung möglich war (45°)???
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Diese Lösung hat natürlich einen großen Nachteil, welcher die Performanz
 des Algorithmus ist, da dieser nun statt einmal pro Durchlauf acht mal
 aufgerufen wird.
 Es ist jedoch nur notwendig beim initialem Ausführen des Softwaremoduls
 den Algorithmus acht mal zu starten, da nach dem ersten Durchlauf des Softwarem
oduls ein Heading an die Brücke gesendet wurde, welches beim nächsten Aufrufen
 des Algorithmus wieder mit gesendet werden kann.
 Mit einem Heading, dass nicht mehr als 
\begin_inset Formula $50°$
\end_inset

 abweicht kann der Algorithmus ohne Probleme arbeiten und muss nun die ARPA-Punk
twolke nur um den Wert des negativen Headings drehen.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
ist das verständlich?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Position-Fix
\end_layout

\begin_layout Subsection
Bestimmung der Eigenposition
\end_layout

\begin_layout Standard
Mit dem Ergebnis des Coherent Point Drift Algorithmus können ARPA - Punkte
 auf ihre zugehörigen AIS - Punkte zugeordnet werden.
 Dadurch ist nun bekannt wo dieser Punkt absolut auf der Karte liegt (AIS-Daten)
 und wie er relativ zu der Schiffseigenposition liegt (ARPA-Daten).
 Durch diese beiden Daten ist es möglich die Schiffseigenposition für jedes
 Paar zugeordneter Punkte zu berechnen.
\begin_inset Newline newline
\end_inset

Damit diese Rückrechnung auf die Eigenposition möglich ist, muss zuerst
 das relative Bearing aus den ARPA - Daten in 
\emph on
true 
\emph default
Bearing umgerechnet werden.
 Als 
\emph on
True
\emph default
 Bearing wird das Bearing bezeichnet, welches relativ zur Nord-Richtung
 angegeben wird.
 Diese Umrechnung ist möglich, da der CPD-Algorithmus auch das Heading des
 Schiffes bestimmt 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Wird das im Programmablauf klar?
\end_layout

\end_inset

.
 Das Heading des Schiffes ist relativ zur Nord-Richtung und bietet somit
 die Möglichkeit über folgende Formel eine relative Bearing Angabe in 
\emph on
True 
\emph default
Bearing umzurechnen:
\end_layout

\begin_layout Standard
\begin_inset Formula $b_{true}:$
\end_inset

 
\emph on
True 
\emph default
Bearing
\end_layout

\begin_layout Standard
\begin_inset Formula $b_{rel}:$
\end_inset

 Relatives Bearing
\end_layout

\begin_layout Standard
\begin_inset Formula $h:$
\end_inset

 Heading des Eigenschiffes
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
b_{true} & = & (b_{rel}-h)\quad mod\:360
\end{eqnarray*}

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Formel nochmal checken
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Nun kann von jedem Datenpaar eine individuelle Eigenposition bestimmt werden.
 Dies basiert auf der Lösung der 1.
 geodätischen Hauptaufgabe, diese ist das berechnen eines Punktes mit einem
 Startpunkt, einer Richtung und einer Distanz.
 Der Startpunkt sind die AIS Koordinaten, die Richtung ist das invertierte
 
\emph on
true 
\emph default
Bearing
\begin_inset Note Note
status open

\begin_layout Plain Layout
gibt es hierfür nicht eine mathematische Bezeichnung?
\end_layout

\end_inset

 und die Distanz kann aus den ARPA - Daten entnommen werden.
 Die Lösung der 1.
 geodätischen Hauptaufgabe lässt sich mithilfe der Vincenty Formel bestimmen.
 
\begin_inset Newline newline
\end_inset

Nachdem dies für jedes Datenpaar wiederholt wurde, existiert eine Punktwolke,
 welche die individuellen Eigenpositionen enthält.
 Zur Bestimmung der Eigenposition wird das arithmetische Mittel über diese
 Punktwolke gebildet.
 Falls die einzelnen Punkte vorher eine Gewichtung besitzen, zur Indizierung
 einer höheren Vertrauenswürdigkeit, kann hier auch das gewichtete arithmetische
 Mittel angewendet werden.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Grafik aus EMS einabuen
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Bestimmung der Sicherheit der Eigenposition und Eliminierung von Ausreißern
\end_layout

\begin_layout Standard
Die Bestimmung der Eigenposition erfolgt über das arithmetische Mittel,
 dieses ist jedoch anfällig für Ausreißer in der Punktwolke.
 Zusätzlich ist es notwendig die bestimmte Eigenposition mit einer Sicherheit
 bzw.
 eines Sicherheitsbereichs angeben zu können.
\end_layout

\begin_layout Standard
Durch die Anfälligkeit des arithmetischen Mittels auf Ausreißer, ist es
 notwendig diese zu bestimmen und in gravierenden Fällen zu eliminieren.
 Dies kann jedoch nur angewendet werden, wenn genügend Punkte in der Punktwolke
 existieren, da sonst Ausreißer nicht eindeutig klassifiziert werden können.
\begin_inset Newline newline
\end_inset

Zur Erkennung der Ausreißer wird die Mahalanobis Distanz verwendet.
 Die Mahalanobis Distanz ist ein Abstandsmaß, welche angibt wie weit ein
 Punkt von der Verteilung einer Punktwolke abweicht.
 Das Ergebnis der Mahalanobis Distanz wird in Standardnormalabweichungen
 angegeben.
 Die Mahalanobis Distanz ist wie folgt definiert: 
\end_layout

\begin_layout Standard
\begin_inset Formula $\vec{X_{i}}=\begin{pmatrix}lat_{i}\\
lon_{i}
\end{pmatrix}:$
\end_inset

 eine Zufallsvariable, welche die zurückgerechnete Position eines Datenpaars
 beschreibt.
 (
\begin_inset Formula $lat$
\end_inset

 ist der Breitengrad und 
\begin_inset Formula $lon$
\end_inset

 der Längengrad des Punktes)
\end_layout

\begin_layout Standard
\begin_inset Formula $\vec{\mu}=\begin{pmatrix}\mu_{lat}\\
\mu_{lon}
\end{pmatrix}:$
\end_inset

 Das arithmetische Mittel der Punktwolke
\end_layout

\begin_layout Standard
\begin_inset Formula $\Sigma:$
\end_inset

 Die Kovarianzmatrix der Punktwolke für welche gilt 
\begin_inset Formula $det(\Sigma)\neq0$
\end_inset


\end_layout

\begin_layout Standard
Mahalanobis-Distanz:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d(\vec{X},\vec{\mu})=\sqrt{(\vec{X}-\vec{\mu})^{T}\cdot\Sigma^{-1}\cdot(\vec{X}-\vec{\mu})}
\]

\end_inset


\begin_inset Newline newline
\end_inset

zur Berechnung der Mahalanobis Distanz wird nun das arithmetische Mittel
 und die Kovarianzmatrix bestimmt, jedoch ohne einbeziehen des Punktes zu
 welchem die Mahalanobis Distanz bestimmt werden soll, da sonst das Ergebnis
 verfälscht wird.
 Nachdem dies für jeden individuelle Eigenposition berechnet wurde ist es
 möglich Punkte zu entfernen, welche außerhalb einer bestimmten Prozentzahl
 der Verteilung liegen.
 Für diese Prozentzahl wurde 
\begin_inset Formula $99,865\%$
\end_inset

 gewählt, das entspricht einem Z-Wert der Standardnormalverteilung von 
\begin_inset Formula $3$
\end_inset

.
 Somit werden Punkte entfernt die Außerhalb von 
\begin_inset Formula $99.865\%$
\end_inset

 der Verteilung liegen.
\begin_inset Newline newline
\end_inset

Nachdem die Ausreißer entfernt wurden ist es wichtig die Genauigkeit des
 Ergebnisses angeben zu können.
 Hierfür wurde sich entschieden einen Sicherheitsbereich zu bestimmen, durch
 welchen eine prozentuale Sicherheit gegeben werden kann, wie wahrscheinlich
 es ist sich in diesem Bereich zu befinden.
 Dieser Sicherheitsbereich wird mithilfe der Mahalanobis Distanz bestimmt.
 Man setzt die Mahalanobis Distanz auf einen festen Wert, wie z.B.
 
\begin_inset Formula $2,33$
\end_inset

 was ca.
 
\begin_inset Formula $99\%$
\end_inset

 Sicherheit entspricht.
 Nun kann durch einsetzen des arithmetischen Mittels und der Kovarianzmatrix
 eine Menge an Punkten bestimmt werden, welche diese Mahalanobis Distanz
 haben.
 Die Form der Punkte entspricht einer Ellipse, welche der Sicherheitsbereich
 ist.
 Eine Visualisierung dieses Ablaufs ist in Abbildung???? zu erkennen.
\begin_inset Note Note
status open

\begin_layout Plain Layout
EMS Grafik
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Sicherheitsbereich über Standardabweichung? eher schlecht wegen der Abweichung,
 ist aktuell jedoch so im Algorithmus umgesetzt.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Erstellung des Ergebnisses
\end_layout

\begin_layout Standard
Nach dem Position-Fix Algorithmus wurden alle benötigten Daten berechnet
 um die Eigenposition, das Heading und eine geeignete Visualisierung darzustelle
n.
 Die Eigenposition und das Heading werden als NMEA-Nachricht an die Brücke
 gesendet, da ihre Daten so intern wie die Daten eines Sensors behandelt
 werden und dadurch eine Integritätsprüfung im Vergleich zu den anderen
 Sensoren möglich ist.
 Die Visualisierung und zusätzliche Daten, wie der Sicherheitsbereich, werden
 über die Netzwerkschnittstelle von Herrn André Becker an die ECDIS übermittelt.
 Die Visualisierung ist eine SVG-Grafik, welche beispielhaft in Abbildung
 ???
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abbildung
\end_layout

\end_inset

 abgebildet ist.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hier Erklärung zu der Visualisierung noch einfügen
\end_layout

\end_inset


\end_layout

\end_body
\end_document
