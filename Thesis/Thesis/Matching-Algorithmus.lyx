#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style german
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Umsetzung
\end_layout

\begin_layout Section
Ansätze
\end_layout

\begin_layout Standard
Im folgenden Abschnitt werden verschiedene Ansätze behandelt, welche im
 Laufe der Arbeit evaluiert wurden.
 Alle diese Ansätze basieren auf dem Prinzip einer rigid Registration, da
 sich die Abstände zwischen Punkten nicht ändern dürfen.
 Der Grund hierfür ist, dass eine Veränderung der Abstände, eine Verfälschung
 des Radarbildes und somit einer Manipulation gleich kommen würde.
 Im Weiteren werden die Stärken und Schwächen der Ansätze betrachtet und
 mit dem ausgewählten Algorithmus verglichen.
\end_layout

\begin_layout Subsection
Iterative Closest Point
\end_layout

\begin_layout Standard
Der 
\emph on
Iterative Closest Point
\emph default
 Algorithmus (ICP) ist ein sehr bekannter und verbreiteter Algorithmus für
 
\emph on
Rigid Registration
\emph default
.
 Es ist einer der ersten Point Set Registration Verfahren und wurde sehr
 oft mit verschiedenen Methoden erweitert.
 Der normale und unveränderte ICP funktioniert wie folgt: 
\end_layout

\begin_layout Standard
Zuerst werden die Transformationsparameter so initialisiert, dass die beiden
 Punktwolken keine zu großen Unterschiede aufweisen, da sonst eine falsche
 Zuordnung für die Punkte resultieren können.
 Danach werden die Transformationsparameter (Rotation, Translation) auf
 eine Punktwolke angewandt, sodass nun für jeden Punkt aus der transformierten
 Punktwolke der dichteste Punkt aus der fixen Punktwolke bestimmt werden
 kann.
 Wenn die Zuordnung bestimmt wurde, kann nun über die Summe der Abstandsquadrate
 zwischen den Punkten ein Fehler zwischen den Punktwolken berechnet werden.
 Wenn der bestimmte Fehler einen Schwellwert unterschreitet ist die Zuordnung
 abgeschlossen.
 Sollte der Fehler zu groß sein, werden die Transformationsparameter anhand
 der gefundenen Zuordnung neu bestimmt und der Algorithmus wird iterativ
 wiederholt.
\begin_inset Newline newline
\end_inset

ICP existiert schon sehr lange, deswegen gibt es eine Vielzahl von Erweiterungen
, wie z.B.
 EM-ICP, welches ICP durch den EM-Algorithmus erweitert 
\begin_inset CommandInset citation
LatexCommand cite
key "EM-ICP"
literal "true"

\end_inset

.
 So existieren noch viele weitere Varianten die ICP für verschiedene Anwendungsf
älle modifiziert haben.
\begin_inset Newline newline
\end_inset

Der ICP Algorithmus ist aufgrund seiner einfachen Funktionsweise sehr performant
 und leicht zu verstehen.
 Außerdem lässt er sich wegen seines modularen Aufbaus sehr gut erweitern
 und verändern, was ihn gut anpassbar für die unterschiedlichen Situationen
 macht.
 Er hat jedoch auch einige Nachteile, diese werden im Folgenden erläutert.
 
\end_layout

\begin_layout Standard
Die Punktwolken müssen initial bereits annähernd zueinander passen, da sonst
 nicht die optimale Lösung bestimmt werden kann.
 Außerdem sorgen fehlende Punkte in einer der Punktwolken für Probleme,
 da diese die Zuordnung verfälschen können und somit ebenso den berechneten
 Fehler.
\begin_inset Newline newline
\end_inset

Der ICP Algorithmus wurde aus folgenden Gründen nicht in dieser Arbeit verwendet
:
\end_layout

\begin_layout Itemize
Die Rotation zwischen den beiden Punktwolken kann beliebig sein und ICP
 kann diese nur in einem kleinen Bereich korrekt finden
\end_layout

\begin_layout Itemize
Es können mehrere Punkte in den Punktwolken fehlen, aufgrund der großen
 Punktmenge, welche aus der Menge an Daten resultiert
\end_layout

\begin_layout Itemize
Die Zuordnung von Punkten ist digital (0 oder 1), was das Erkennen von Fehlern
 oder das bestimmen einer Vertrauenswürdigkeit sehr schwer macht
\end_layout

\begin_layout Subsection
Subgraph Matching
\end_layout

\begin_layout Standard
Das Subgraph Matching ist ein weiterer Ansatz, um eine Zuordnung zwischen
 den Punktwolken wiederherzustellen.
 Hierfür wurde versucht die Punktwolken als zwei vollvermaschte Graphen
 zu betrachten.
 
\begin_inset Newline newline
\end_inset

Das Subgraph Matching auch Sub-Graph Isomorphismus Problem genannt, basiert
 auf zwei gegebenen Graphen 
\begin_inset Formula $G$
\end_inset

 und 
\begin_inset Formula $H$
\end_inset

, wobei gezeigt werden soll, dass 
\begin_inset Formula $G$
\end_inset

 einen Subgraph isomorph zu 
\begin_inset Formula $H$
\end_inset

 enthält.
 Die Eigenschaft isomorph bedeutet, dass eine Bijektion zwischen den Kanten
 von 
\begin_inset Formula $G$
\end_inset

 und 
\begin_inset Formula $H$
\end_inset

 existiert, sodass zwei benachbarte Kanten in 
\begin_inset Formula $G$
\end_inset

 auch in 
\begin_inset Formula $H$
\end_inset

 benachbarten Kanten entsprechen.
 Für dieses Problem existieren bereits Algorithmen, welche es für große
 Graphen lösen können 
\begin_inset CommandInset citation
LatexCommand cite
key "GraphIsomorphism"
literal "true"

\end_inset

.
\begin_inset Newline newline
\end_inset

Die Stärke dieses Ansatzes ist die Genauigkeit, da das Finden eines Subgraphen
 eine eindeutige Zuordnung zur Folge hätte, welche je nach Größe des Subgraphs
 auch als dementsprechend sicher einzustufen wäre.
 Durch die gefundene Zuordnung ist nun auch die Rotation zwischen den Punktwolke
n berechenbar.
\begin_inset Newline newline
\end_inset

Der Ansatz hat im Kontext dieser Arbeit eine Schwäche, diese ist das fehlende
 Erkennen von Ausreißern.
\begin_inset Newline newline
\end_inset

Das Graph Matching kann mit Ausreißern nicht arbeiten, da es keine fehlenden
 Punkte erkennen kann und ein vollvermaschter Graph sich zusätzlich negativ
 auf die Laufzeit auswirkt.
 Die Ausreißer bei diesem Problem können in AIS- sowie ARPA-Punktwolken
 existieren.
 In der AIS-Punktwolke existieren mehr Punkte als in der ARPA-Punktwolke,
 weil AIS eine höhere Reichweite als das Radar hat und AIS geografisch nicht
 durch verschiedene Höhen beschränkt ist.
\begin_inset Newline newline
\end_inset

Außerdem kann die ARPA-Punktwolke auch Punkte enthalten, die in der AIS-Punktwol
ke fehlen.
 Dies ist möglich, falls ein Schiff kein AIS sendet oder Radarschatten fälschlic
h für Schiffe gehalten werden.
 Zusätzlich ist der Ansatz sehr Laufzeit intensiv, da die beiden Graphen
 zuerst erstellt werden müssen, wofür die Distanz zwischen allen Punkten
 berechnet werden muss.
 Hierbei würden weitere Probleme entstehen, falls gleiche Distanzen mehrfach
 auftreten bzw.
 wie diese gleichen Distanzen auseinandergehalten werden könnten.
\end_layout

\begin_layout Subsection
Coherent Point Drift
\end_layout

\begin_layout Standard
Der in dieser Arbeit verwendete Algorithmus ist der Coherent Point Drift
 Algorithmus.
 Die Wahl für diesen Algorithmus wird im Folgenden genauer erklärt.
\begin_inset Newline newline
\end_inset

Der CPD hat eine weiche Zuordnung (Wert zwischen 0 und 1), anstatt einer
 digitalen Zuordnung(0 oder 1) wie der ICP Algorithmus.
 Durch diese weiche Zuordnung ist es auch möglich, eine Aussage über die
 Vertrauenswürdigkeit eines Zuordnungspaares zu treffen.
 Somit kann Punkten, welche sicher zugeordnet werden konnten eine hohe Vertrauen
swürdigkeit zugesprochen werden.
 Eine hohe Vertrauenswürdigkeit indiziert also, dass die ARPA und AIS-Daten
 zusammenpassen.
\begin_inset Newline newline
\end_inset

Eine weitere wichtige Eigenschaft von CPD ist, dass es möglich ist Ausreißer
 in den Punktwolken zu erkennen, solange man deren Menge im Vergleich zur
 Gesamtheit abschätzen kann.
\begin_inset Newline newline
\end_inset

Zusätzlich kann der CPD mehrfach ausgeführt eine beliebige Rotation der
 Punktwolke erkennen (siehe Kapitel 4.2.3), was essenziell für die Bestimmung
 des Headings des Schiffes ist (siehe 4.2.1).
 Dies funktioniert jedoch nur für einen bestimmten Bereich, da der CPD nur
 ein lokales Maximum finden kann.
 Auf dieses Problem wird in 4.2.3 genauer eingegangen.
\begin_inset Newline newline
\end_inset

In der folgenden Tabelle 4.1 ist die Entscheidungsfindung für das Verfahren
 tabellarisch gegenübergestellt anhand der Anforderungen.
 Zu erkennen sind die einzelnen Stärken der Ansätze und welche Eigenschaften
 fehlen, um das hier betrachtete Problem effektiv zu lösen.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ICP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Subgraph Matching
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPD
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rauschen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ja
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nein
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ja
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rotation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nein
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ja
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
teilweise
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ausreißer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nein
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
teilweise (nur wenige)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ja
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
soft assignment
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nein
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nein
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ja
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Vor- und Nachteile der Ansätze
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Implementierung des CPD Algorithmus basiert auf der Arbeit von Gadomski
 
\begin_inset CommandInset citation
LatexCommand cite
key "CPD_C++"
literal "true"

\end_inset

.
 Es steht unter der General Public License 2 (GPL2).
 In dieser ist der Algorithmus mithilfe der Eigen3 Bibliothek implementiert.
 Die Eigen3 Bibliothek umfasst Methoden für Matrizen Berechnung, sowie Methoden
 zur Singulärwertzerlegung.
 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "GPL2"
description "General Public License 2"
literal "false"

\end_inset


\begin_inset Newline newline
\end_inset

Der von Gadomski implementierte CPD ist nicht der originale CPD.
 Er bietet weitere Möglichkeiten, wie das Spiegeln und Skalieren bei rigid
 Transformationen, jedoch auch die Möglichkeit, diese zusätzlichen Transformatio
nen nicht zu verwenden.
\begin_inset Newline newline
\end_inset

Der Algorithmus gibt die Möglichkeit vor der Ausführung mehrere Einstellungen
 zu treffen.
 Hier wurden Folgende Einstellungen getroffen:
\end_layout

\begin_layout Enumerate
Spiegelung wurde als Transformation ausgeschlossen
\end_layout

\begin_layout Enumerate
Skalierung wurde als Transformation ausgeschlossen
\end_layout

\begin_layout Enumerate
Die Ausgabe der Zuordnung der Punkte wurde als Rückgabe festgelegt
\end_layout

\begin_layout Standard
Die Transformationen Skalierung wurden ausgeschlossen, weil das die Punktwolke
 in ihrer Form verändern würde.
 Die Spiegelung wurde ebenfalls deaktiviert, weil die ARPA- und AIS-Daten
 bereits korrekt gespiegelt sind.
\begin_inset Note Note
status open

\begin_layout Plain Layout
spiegelkorrekt?
\end_layout

\end_inset

 Das ist nicht gewünscht, weil ARPA- und AIS-Daten bereits seitenrichtig
 und in einer einheitlichen Skalierung vorliegen.
\end_layout

\begin_layout Section
Implementierung
\end_layout

\begin_layout Subsection
Programmablauf
\end_layout

\begin_layout Standard
Das entstandene Softwaremodul umfasst verschiedene Abläufe, welche zum besseren
 Verständnis erläutert werden.
\end_layout

\begin_layout Standard
In Abbildung 4.1 ist der Ablauf der Software anhand eines Aktivitätsdiagramms
 dargestellt, dieser wird im Folgenden genauer erläutert.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/User/Desktop/Repositorys/Thesis/Thesis/Grafiken/ProgrammAblauf.png
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Aktivitätsdiagramm des Softwaremoduls 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zuerst werden die benötigten Daten von der Brücke als NMEA-Nachrichten eingelese
n.
 Dies geschieht durch einen NMEA-Parser von Raytheon Anschütz, welcher in
 das Modul eingebunden ist.
\end_layout

\begin_layout Standard
Im Folgenden wird ein Algorithmus ausgewählt, welcher passend zu den verfügbaren
 Daten den weiteren Ablauf bestimmt.
 Die folgenden Daten werden hier auf ihre Existenz geprüft:
\end_layout

\begin_layout Enumerate
AIS Daten umliegender Schiffe und AtoNs
\end_layout

\begin_layout Enumerate
Die Geschwindigkeit des eigenen Schiffes
\end_layout

\begin_layout Enumerate
Empfangene AIS-Daten von mindestens drei AtoNs
\end_layout

\begin_layout Standard
Anhand dieser Daten wird ein Algorithmus ausgewählt, welcher in der jeweiligen
 Situation das beste Ergebnis erzielt.
\end_layout

\begin_layout Standard
Der bestimmte Algorithmus gibt an, welche der drei Filter auf die Daten
 angewendet werden müssen, um die relevanten Daten zu extrahieren.
 Diese drei sind, das Filtern nach den neuesten AIS und ARPA Daten der Schiffe,
 das Filtern nach den AtoNs im AIS und das Filtern nach ARPA Daten, welche
 keine Geschwindigkeit aufweisen.
\begin_inset Newline newline
\end_inset

Zusätzlich zu diesen drei Filtern werden die AIS-Daten mithilfe von Seekarten
 Informationen abgeglichen.
 Bei diesem Abgleich werden fehlende AtoNs im AIS durch die Informationen
 der Seekarte ergänzt.
 Dies ist möglich, da alle AtoNs in der Seekarte verzeichnet sind.
 
\end_layout

\begin_layout Standard
Nach der Anwendung der Filter auf die Daten wird der Zeitverzug der AIS-Daten
 korrigiert.
 Dieser Zeitverzug existiert, da AIS-Nachrichten in einer Frequenz zwischen
 drei Sekunden bis zwei Minuten gesendet werden können.
 Die Sendezeit ist abhängig von der Geschwindigkeit und der Kursänderung
 des Schiffes.
 Die Radarantenne, welche für die ARPA-Daten zuständig ist, benötigt jedoch
 für eine volle Umdrehung bzw.
 für das Erfassen aller umliegenden Schiffe nur ca.
 zwei bis vier Sekunden.
 Dieser zeitliche Versatz, zwischen den beiden Datensätzen, hat falls er
 nicht raus gerechnet wird, einen großen Einfluss auf die Genauigkeit der
 Zuordnung des Algorithmus.
 
\end_layout

\begin_layout Standard
Im Folgenden startet der spezifische Algorithmus, die einzelnen Komponenten
 des Algorithmus werden im Laufe der Arbeit genauer behandelt, so wird 
\emph on
AIS zum Koordinaten-Ursprung verschieben
\emph default
 in Unterabschnitt 4.2.2 behandelt und wie das initiale Heading den Algorithmus
 beeinflusst, wird in 4.2.3 erklärt.
 
\begin_inset Newline newline
\end_inset

Nachdem alle Methoden zur Reduzierung von Ungenauigkeiten ausgeführt wurden,
 müssen die ARPA-Daten, welche in Polarkoordinaten vorliegen, in geodätische
 Koordinaten umgewandelt werden.
 Hierfür wird ein Punkt gewählt und die Punktwolke von diesem aus konstruiert.
 Wie dieser Punkt optimalerweise gewählt werden muss, ist in 4.2.2 beschrieben.
\begin_inset Newline newline
\end_inset

Nun kann der CPD mit den beiden Punktwolken als Parameter gestartet werden
 und liefert ein Ergebnis.
 Das Ergebnis des Algorithmus ist die Zuordnung zwischen den Punkten und
 des Rotationsunterschieds, welcher benötigt wurde, um die Punktwolken ineinande
r zu überführen.
 Die Zuordnung wird für den in 4.3 erklärten Position-Fix Algorithmus benötigt
 und die bestimmte Rotation entspricht dem Heading des Eigenschiffes.
 Die Bestimmung des Headings auf diese Weise ist möglich, da die ARPA-Daten
 von der relativen Ausrichtung des Schiffes abhängen, die AIS-Daten jedoch
 nach Norden ausgerichtet sind.
 Somit entspricht eine Drehung der ARPA-Punktwolke, bis sie mit der AIS-Punktwol
ke übereinstimmen, dem Winkel zwischen der Ausrichtung des Schiffes und
 der Himmelsrichtung Norden.
 Dies ist der Winkel, in welchem das Heading eines Schiffes angegeben wird.
 Eine genaue Berechnung hierzu ist in Abschnitt 4.3.1 zu finden.
\end_layout

\begin_layout Standard
Mit der Zuordnung der Daten kann nun der Position-Fix die Eigenposition
 bestimmen (4.3) und diese als Positionsangabe über eine NMEA-Nachricht an
 die Brücke senden.
 Zusätzlich wird eine Visualisierung des Ergebnisses über die von Herrn
 André Becker entwickelte Netzwerkschnittstelle an die Seekarte (ECDIS)
 gesendet.
\end_layout

\begin_layout Subsection
Ungenauigkeiten durch den Erdellipsoid
\end_layout

\begin_layout Standard
Der Coherent Point Drift Algorithmus basiert auf Koordinaten in kartesischer
 Form.
 In dieser Arbeit wurde dieser auf geodätische Koordinaten angewendet.
 Wodurch einige Genauigkeitsprobleme entstehen, die im Weiteren erläutert
 werden.
\begin_inset Newline newline
\end_inset

Das erste Problem beruht auf der Translation, die der Algorithmus anwendet,
 um die Distanz zwischen zwei Punktwolken zu minimieren.
 
\begin_inset Newline newline
\end_inset

Die Translation basiert auf der Distanz zwischen den Schwerpunkten der Punktwolk
en.
 Dies ist zwar in einem kartesischen Koordinatensystem korrekt, in dem der
 Abstand zwischen zwei Punkten über die euklidische Norm bestimmt werden
 kann, jedoch nicht wenn mit geodätische Koordinaten gerechnet wird.
 Der Grund hierfür ist, dass der Abstand zwischen den Längengraden zwischen
 Nord- bzw.
 Südpol und dem Äquator sich je nach Position ändert.
 Als Folge hiervon ist es zwar möglich die Punktwolken zueinander zu bewegen,
 jedoch ist die Translation, welche der Algorithmus bestimmt, mit einem
 Fehler versehen.
 Der Abstand zwischen den Punktwolken kann beliebig groß sein, da die ARPA-Punkt
wolke ohne eine absolute Positionsangabe in Polarkoordinaten vorliegt und
 somit eine initiale Position benötigt wird, um aus dieser geodätische Koordinat
en zu erstellen.
 
\begin_inset Newline newline
\end_inset

Das zweite Problem entsteht durch die Rotation, welche Teil des Algorithmus
 ist.
 Bei einer Rotation werden alle Punkte einer Punktwolke um den Ursprung
 des Koordinatensystems gedreht und erhalten somit eine neue Position.
 Durch das Rotieren einer kartesischen Punktwolke um den Ursprung ändern
 sich die Positionen der Punkte, jedoch nicht die Abstände zwischen den
 Punkten.
 Wenn man geodätische Koordinaten rotiert, ändern sich ebenso die Positionen
 der Punkte, jedoch ändert sich hier auch der Abstand zwischen den Punkten,
 aufgrund der unterschiedlichen Abstände zwischen Längengraden.
 Die Abweichungen steigen mit dem Abstand zwischen den Punktwolken.
\begin_inset Newline newline
\end_inset

Die Lösung für das erste Problem (Translation) ist das eliminieren der Abstände
 zwischen den Schwerpunkten der Punktwolken.
 Die Translation, die für das Überführen der einen Punktwolke in die andere
 benötigt wird, resultiert in einer kleinen Abweichung.
\begin_inset Newline newline
\end_inset

Die Lösung für das zweite Problem (Rotation) ist das Verschieben des Schwerpunkt
es der zu rotierenden Punktwolke in den Ursprung des Koordinatensystems.
 Eine Rotation dieser Punktwolke bewirkt nun, dass der Schwerpunkt seine
 Position nicht verändert, wodurch die Punkte der Punktwolke eine minimale
 Positionsänderung durch eine Rotation erfahren.
\begin_inset Newline newline
\end_inset

Somit ist die Lösung für diese Probleme die Translation beider Punktwolken
 auf den Ursprung des Koordinatensystems, um so die Ungenauigkeiten so gering
 wie möglich zu halten.
 Dies hat auch den Effekt, dass Fehler, welche durch das Verwenden der euklidisc
hen Norm auf dem Erdellipsoid entstehen, geringer ausfallen, weil Längen-
 und Breitengrad im Ursprung des Koordinatensystems fast gleich lang sind.
\begin_inset Newline newline
\end_inset

Für die ARPA - Punktwolke ist dies trivial, da aufgrund der Radar Daten
 diese Punkte in Polarkoordinaten angegeben sind.
 
\begin_inset Newline newline
\end_inset

Die AIS - Punktwolke ist jedoch an ihre absolute Position gebunden, deswegen
 ist eine andere Methodik notwendig, um die Punktwolke, ohne Änderung der
 Abstände zwischen den Punkten, verschieben zu können.
 Die Methodik sieht das Bestimmen des Schwerpunktes vor.
 Zu diesem wird der Abstand und der Richtungswinkel zu jedem Punkt bestimmt.
 Nun kann der Schwerpunkt verschoben werden und durch die vorher gewonnenen
 Informationen lässt sich die Punktwolke an einem anderen Punkt wiederherstellen.
 Der zu bestimmende Punkt ist der Schwerpunkt der AIS-Punktwolke, welcher
 sich über das arithmetische Mittel bestimmen lässt, solange es sich um
 eine nicht gewichtete Punktwolke handelt.
 Für die Berechnung der Distanz und der Winkel zwischen den Punkten wird
 die Vincenty Formel verwendet, damit keine Fehler durch die Erdkrümmung
 entstehen.
 Nun liegt die AIS-Punktwolke theoretisch in Polarkoordinaten vor.
 Das macht es möglich sie ebenso wie die ARPA - Punktwolke an den Ursprung
 zu platzieren.
 
\begin_inset Newline newline
\end_inset

Nun sind optimale Bedingungen geschaffen, um eine Zuordnung zwischen den
 Punktwolken durch den Coherent Point Drift Algorithmus zu bestimmen.
\end_layout

\begin_layout Subsection
Rotationsschwäche von Coherent Point Drift
\end_layout

\begin_layout Standard
Das erkennen von Rotation ist eine essenzielle Eigenschaft, welche der Algorithm
us benötigt um die Punktwolken einander zuzuordnen und somit auch das Heading
 des Eigenschiffes zu bestimmen.
 Die Rotation kann jedem beliebigen gültigen Wert entsprechen, da die Drehung
 der ARPA Punktwolke abhängig vom Heading ist und die Drehung der AIS Punktwolke
 immer nach Norden ausgerichtet ist.
 Somit ist jeder Rotationswinkel eine mögliche Lösung und das Problem kann
 nicht vorher behandelt werden.
\end_layout

\begin_layout Standard
Der CPD kann nur ein lokales Minima finden, da er auf dem EM-Algorithmus
 basiert.
 Die erkennbare Rotation liegt nach Golyanik bei ca.
 
\begin_inset Formula $65$
\end_inset

 Grad 
\begin_inset CommandInset citation
LatexCommand cite
key "GA-comp-CPD-ICP"
literal "true"

\end_inset

.
 Bei Punktwolken, welche mehr als 
\begin_inset Formula $65$
\end_inset

 Grad Rotationsunterschied besitzen, findet der Algorithmus möglicherweise
 nur ein lokales Minima.
 Ein hierzu ausgeführter Versuch mit perfekten Daten beweist diese These
 (Tabelle 4.2).
\begin_inset Newline newline
\end_inset

In Tabelle 4.2 wurden die Ergebnisse des CPD Algorithmus für verschiedene
 Rotationen bestimmt.
 Diese Messung wurde mit perfekten Daten ausgeführt, dies bedeutet, dass
 alle Punkte zugeordnet werden können.
 Zudem ist es möglich die Punkte perfekt aufeinander zuzuordnen, sodass
 lediglich der Rotationswinkel der Punktwolken sie voneinander unterscheidet.
 Die Punkte der Punktwolke wurden zufällig anhand einer Normalverteilung
 erstellt und besteht aus 20 Punkten in geodätischen Koordinaten.
 Alle Angaben sind in Grad angegeben.
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rotationswinkel (°)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gefundenes Minima (°)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 - 70
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
80 - 140
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150 - 160
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
172
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
170 - 220
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
230
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
230 - 300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
282
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
310 - 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Bestimmte Rotation durch CPD an perfekten Daten
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es ist deutlich zu erkennen, dass der CPD Algorithmus ab einem bestimmten
 Rotationswinkel, die korrekte Rotation nicht mehr findet und in einem lokalen
 Minimum terminiert.
 In den Testdaten von Tabelle 4.2 werden fünf verschiedene Minima gefunden,
 welche von je nach Rotation der Punktwolke gefunden werden.
 
\end_layout

\begin_layout Standard
Für dieses Problem wurde eine Lösung entwickelt, um die korrekte Rotation
 sowie Zuordnung zu bestimmen.
 
\begin_inset Newline newline
\end_inset

Hierfür wird der Algorithmus mehrfach ausgeführt, wobei nach jeder Ausführung
 die ARPA-Punktwolke rotiert wird und die Ergebnisse gespeichert werden.
 Für die kontinuierliche Rotation wurden 
\begin_inset Formula $45$
\end_inset

 Grad gewählt.
 Es wurden 
\begin_inset Formula $45$
\end_inset

 Grad gewählt anstatt den gemessenen 
\begin_inset Formula $65$
\end_inset

 Grad, weil diese Messung ohne Ausreißer stattfand und außerdem noch weitere
 Abweichungen das Ergebnis beeinflussen können.
 Eine dieser zu beachtenden Abweichungen ist, dass euklidische Transformationen
 auf geodätische Daten angewandt werden, was in Abweichungen resultiert.
 Die Rotation der ARPA-Punktwolke ist sehr simple, da sie bereits in Polarkoordi
naten vorliegt.
 Nachdem der Algorithmus achtmal ausgeführt wurde (
\begin_inset Formula $\frac{360}{45}=8$
\end_inset

) werden die Ergebnisse verglichen.
 Hierbei wird das Ergebnis mit dem geringsten Fehler zwischen den Punkten
 ausgewählt, da so das globale Optimum gefunden wird.
\begin_inset Newline newline
\end_inset

Diese Lösung hat natürlich einen großen Nachteil, welcher die Performanz
 des Algorithmus ist.
 Der Algorithmus muss achtmal gestartet werden um ein korrektes Ergebnis
 zu produzieren.
 Die achtfache Ausführung ist jedoch nur beim initialen Ausführen des Softwaremo
duls nötig, weil nach dem ersten Durchlauf des Softwaremoduls ein Heading
 an die Brücke gesendet wird, welches beim nächsten Aufrufen des Algorithmus
 mit gesendet wird und somit ein initiales Heading existiert.
 Wenn ein Heading mit gesendet wird, muss der Algorithmus nur einmal ausgeführt
 werden, weil die ARPA-Punktwolke nur um den Wert des negativen Headings
 gedreht werden muss und dadurch die Punktwolken eine ähnliche Rotation
 aufweisen sollten.
\end_layout

\begin_layout Section
Position-Fix
\end_layout

\begin_layout Standard
Der folgende Abschnitt beschreibt die Berechnung der Eigenposition und des
 Sicherheitsbereichs, welche aus der Zuordnung und dem bestimmten Heading
 des CPD möglich ist.
\end_layout

\begin_layout Subsection
Bestimmung der Eigenposition
\end_layout

\begin_layout Standard
Mit dem Ergebnis des Coherent Point Drift Algorithmus können ARPA - Punkte
 auf ihre zugehörigen AIS - Punkte zugeordnet werden.
 Dadurch ist nun bekannt, wo dieser Punkt absolut auf der Karte (AIS-Daten)
 und wie er relativ zu der Schiffseigenposition liegt (ARPA-Daten).
 Durch diese beiden Daten ist es möglich, die Schiffseigenposition für jedes
 Paar zugeordneter Punkte zu berechnen.
\begin_inset Newline newline
\end_inset

Derzeit wird bei Versagen der GPS-Analge die Eigenposition von der Besatzung
 des Schiffes bestimmt.
 Hierfür werden markante Ziele im AIS gesucht wie unter anderem Leuchttürme.
 Danach muss der Nautiker überprüfen, in welchem Winkel dieses Ziel zum
 eigenen Schiff liegt und so selber den passenden Radarpunkt identifizieren.
 Dies wird für zwei bis drei Ziele wiederholt, womit der Nautiker nun die
 Eigenposition berechnen kann.
 Dies ist sehr aufwendig und soll von dem hier entwickelten Algorithmus
 möglichst ohne manuelle Eingaben umgesetzt werden.
 Dessen Funktionsweise wird im Weiteren genauer beschrieben.
\end_layout

\begin_layout Standard
Damit diese Rückrechnung auf die Eigenposition möglich ist, muss zuerst
 das relative Bearing aus den ARPA - Daten in 
\emph on
true 
\emph default
Bearing umgerechnet werden.
 Als 
\emph on
True
\emph default
 Bearing wird das Bearing bezeichnet, welches relativ zur Nord-Richtung
 angegeben wird.
 Diese Umrechnung ist möglich, da der CPD-Algorithmus auch das Heading des
 Schiffes bestimmt.
 Das Heading des Schiffes ist relativ zur Nord-Richtung und bietet somit
 die Möglichkeit über folgende Formel eine relative Bearing Angabe in 
\emph on
True 
\emph default
Bearing umzurechnen:
\end_layout

\begin_layout Standard
\begin_inset Formula $b_{true}:$
\end_inset

 
\emph on
True 
\emph default
Bearing
\end_layout

\begin_layout Standard
\begin_inset Formula $b_{rel}:$
\end_inset

 Relatives Bearing
\end_layout

\begin_layout Standard
\begin_inset Formula $h:$
\end_inset

 Heading des Eigenschiffes
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
b_{true} & = & (b_{rel}-h)\quad mod\:360
\end{eqnarray*}

\end_inset


\begin_inset Newline newline
\end_inset

Nun kann von jedem Datenpaar eine individuelle Eigenposition bestimmt werden.
 Dies basiert auf der Lösung der 1.
 geodätischen Hauptaufgabe, diese ist das Berechnen eines Punktes mit einem
 Startpunkt, einer Richtung und einer Distanz.
 Der Startpunkt sind die AIS Koordinaten, die Richtung ist das negierte
 
\emph on
true 
\emph default
Bearing und die Distanz kann aus den ARPA - Daten entnommen werden.
 Die Lösung der 1.
 geodätischen Hauptaufgabe lässt sich mithilfe der Vincenty Formel bestimmen.
 
\begin_inset Newline newline
\end_inset

Nachdem dies für jedes Datenpaar wiederholt wurde, existiert eine Punktwolke,
 welche die individuellen Eigenpositionen enthält.
 Zur Bestimmung der Eigenposition wird das arithmetische Mittel über diese
 Punktwolke gebildet.
 Falls die einzelnen Punkte vorher eine Gewichtung besitzen, was zur Indizierung
 einer höheren Vertrauenswürdigkeit verwendet werden kann, kann hier auch
 das gewichtete arithmetische Mittel angewendet werden.
\begin_inset Newline newline
\end_inset

Die Auswirkung für die Verwendung eines gewichteten arithmetischen Mittels
 anstatt des normalen arithmetischen Mittels ist in Abbildung 4.2 zu erkennen.
 In der Abbildung haben die Punkte 6 - 10 eine höhere Gewichtung als die
 Punkte 1 - 4.
 Das sorgt dafür, dass diese beim gewichteten Arithmetischen Mittel stärker
 berücksichtigt werden.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/User/Desktop/Repositorys/Thesis/Thesis/Grafiken/WeightedAndArithmeticMean.PNG

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Arithmetisches Mittel der individuell zurückgerechneten Eigenpositionen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Abbildung zeigt, wie stark die Genauigkeit der Positionsbestimmung erhöht
 werden kann, falls es möglich ist, eine Aussage über die Genauigkeit oder
 die Vertrauenswürdigkeit der einzelnen Punkte treffen zu können.
 Ein Maß hierfür könnte die Zuordnungswahrscheinlichkeit des CPD sein oder
 die Unterscheidung zwischen AtoNs und Schiffen.
\end_layout

\begin_layout Subsection
Bestimmung der Sicherheit der Eigenposition und Eliminierung von Ausreißern
\end_layout

\begin_layout Standard
Die Bestimmung der Eigenposition erfolgt über das arithmetische Mittel,
 dieses ist jedoch anfällig für Ausreißer in der Punktwolke.
 Zusätzlich ist es notwendig, die bestimmte Eigenposition mit einer Sicherheit
 bzw.
 eines Sicherheitsbereichs angeben zu können.
\end_layout

\begin_layout Standard
Durch die Anfälligkeit des arithmetischen Mittels auf Ausreißer ist es notwendig
, diese zu bestimmen und in gravierenden Fällen zu eliminieren.
 Dies kann jedoch nur angewendet werden, wenn genügend Punkte in der Punktwolke
 existieren, da sonst Ausreißer nicht eindeutig klassifiziert werden können.
\begin_inset Newline newline
\end_inset

Zur Erkennung der Ausreißer wird die Mahalanobis Distanz verwendet.
 Die Mahalanobis Distanz ist ein Abstandsmaß, welche angibt, wie weit ein
 Punkt von der Verteilung einer Punktwolke abweicht.
 Das Ergebnis der Mahalanobis Distanz wird in Standardnormalabweichungen
 angegeben.
 Die Mahalanobis Distanz ist wie folgt definiert: 
\end_layout

\begin_layout Standard
\begin_inset Formula $\vec{X_{i}}=\begin{pmatrix}lat_{i}\\
lon_{i}
\end{pmatrix}:$
\end_inset

 eine Zufallsvariable, welche die zurückgerechnete Position eines Datenpaars
 beschreibt.
 (
\begin_inset Formula $lat$
\end_inset

 ist der Breitengrad und 
\begin_inset Formula $lon$
\end_inset

 der Längengrad des Punktes)
\end_layout

\begin_layout Standard
\begin_inset Formula $\vec{\mu}=\begin{pmatrix}\mu_{lat}\\
\mu_{lon}
\end{pmatrix}:$
\end_inset

 Das arithmetische Mittel der Punktwolke
\end_layout

\begin_layout Standard
\begin_inset Formula $\Sigma:$
\end_inset

 Die Kovarianzmatrix der Punktwolke für welche gilt 
\begin_inset Formula $det(\Sigma)\neq0$
\end_inset


\end_layout

\begin_layout Standard
Mahalanobis-Distanz:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d(\vec{X},\vec{\mu})=\sqrt{(\vec{X}-\vec{\mu})^{T}\cdot\Sigma^{-1}\cdot(\vec{X}-\vec{\mu})}
\]

\end_inset


\begin_inset Newline newline
\end_inset

Zur Berechnung der Mahalanobis Distanz wird nun das arithmetische Mittel
 und die Kovarianzmatrix bestimmt, jedoch ohne Einbeziehung des Punktes,
 zu welchem die Mahalanobis Distanz bestimmt werden soll, da sonst das Ergebnis
 verfälscht wird.
 Nachdem dies für jede individuelle Eigenposition berechnet wurde, ist es
 möglich, Punkte zu entfernen, welche außerhalb einer bestimmten Prozentzahl
 der Verteilung liegen.
 Für diese Prozentzahl wurde 
\begin_inset Formula $99,865\%$
\end_inset

 gewählt, das entspricht einem Z-Wert der Standardnormalverteilung von 
\begin_inset Formula $3$
\end_inset

.
\begin_inset Newline newline
\end_inset

Nachdem die Ausreißer entfernt wurden, ist es wichtig, die Genauigkeit des
 Ergebnisses angeben zu können.
 Hierfür wurde sich entschieden einen Sicherheitsbereich zu bestimmen, durch
 welchen eine prozentuale Sicherheit gegeben werden kann, wie wahrscheinlich
 es ist sich in diesem Bereich zu befinden.
 Dieser Sicherheitsbereich wird mithilfe der Mahalanobis Distanz bestimmt.
 Man setzt die Mahalanobis Distanz auf einen festen Wert, wie z.
 B.
 
\begin_inset Formula $2,33$
\end_inset

 was ca.
 
\begin_inset Formula $99\%$
\end_inset

 Sicherheit entspricht.
 Nun kann durch einsetzen des arithmetischen Mittels und der Kovarianzmatrix
 eine Menge an Punkten bestimmt werden, welche diese Mahalanobis Distanz
 haben.
 Die Form der Punkte entspricht einer Ellipse, welche der Form und Größe
 des Sicherheitsbereichs entspricht.
 Eine Visualisierung dieses Ablaufs ist in Abbildung 4.3 zu erkennen.
 Die roten Punkte sind zurückgerechnete Eigenpositionen, wobei 10 ein Ausreißer
 ist, welcher das Resultat einer falschen Zuordnung sein könnte.
 Die Ellipsen indizieren die Standardabweichungen vom Faktor 0.5 bis 2 von
 innen nach außen.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/User/Desktop/Repositorys/Thesis/Thesis/Grafiken/OutlierRemoval.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Eliminierung von Ausreißern und Darstellung des Sicherheitsbereichs
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es ist klar, zu erkennen, wie groß die Auswirkung eines Ausreißers auf die
 Eigenposition und den Sicherheitsbereich ist.
 Deshalb ist diese Methode zum Erkennen und Ausschließen des Ausreißers
 sehr wichtig, um auch in Fehlerfällen eine sichere und möglichst genaue
 Eigenposition bestimmen zu können.
\end_layout

\begin_layout Subsection
Erstellung des Ergebnisses
\end_layout

\begin_layout Standard
Nach dem Position-Fix Algorithmus wurden alle benötigten Daten berechnet
 um die Eigenposition, das Heading und eine geeignete Visualisierung darzustelle
n.
 Die Eigenposition und das Heading werden als NMEA-Nachricht an die Brücke
 gesendet, da ihre Daten so intern wie die Daten eines Sensors behandelt
 werden und dadurch eine Integritätsprüfung im Vergleich zu den anderen
 Sensoren möglich ist.
 Die Visualisierung wird über die Netzwerkschnittstelle von Herrn André
 Becker an die ECDIS übermittelt.
 Diese muss in Form einer SVG-Grafik gesendet werden, da sie sonst nicht
 verlustfrei skaliert werden kann.
\end_layout

\begin_layout Standard
Für die Visualisierung sind mehrere Ansätze entstanden im Folgenden wird
 auf diese genauer eingegangen.
\begin_inset Newline newline
\end_inset

Der erste Ansatz basiert auf dem Ziel, dass der Nautiker die bestimmte Eigenposi
tion möglichst gut nachvollziehen und mögliche Fehler erkennen kann.
 Deswegen wurde darauf Wert gelegt möglichst viele wichtige Informationen
 in die Grafik zu integrieren.
 Diese ist in Abbildung 4.4 dargestellt.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align right
\begin_inset Graphics
	filename C:/Users/User/Desktop/Repositorys/Thesis/Thesis/Grafiken/posFix.svg
	scale 20
	BoundingBox 0bp 0bp 2400bp 1215bp

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Visualisierung viele Informationen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In der Abbildung 4.4 ist die Eigenposition mit einem blauen Rechteck gekennzeichn
et, welches mit einem Strich sein Heading kennzeichnet.
 Zusätzlich sind vier Ziele zu sehen inklusive ihrer Radar-Daten und AIS-ID,
 dadurch ist es möglich das Ergebnis nachzuprüfen und Fehler direkt zu erkennen.
 Die Linien von den Zielen Enden in der von diesem Ziel zurückgerechneten
 Eigenposition, welche für jedes Ziel individuell ist.
 Die Grafik wurde anhand perfekter Daten erstellt, deswegen führen alle
 Linien direkt zur Eigenposition.
 Die Ziele sind zusätzlich in grün, gelb oder rot eingefärbt.
 Die Farben sind ein Indikator, wie gut sie zugeordnet werden konnten und
 somit auch wie vertrauenswürdig ein Ziel ist.
 
\begin_inset Newline newline
\end_inset

Im Laufe des Projekts wurde entschieden diese Visualisierung nicht zu nutzen.
 Der Grund hierfür ist, dass die ECDIS bereits sehr viele Informationen
 darstellt, was schnell unübersichtlich sein kann.
 Deswegen wurde es als kontraproduktiv eingeschätzt noch viele weitere Informati
onen hinzuzufügen und somit der Übersicht zu schaden.
 Dieser Ansatz wäre eine Alternative, wenn Informationen klar ein und ausgeblend
et werden können.
 
\end_layout

\begin_layout Standard
Eine weitere Visualisierung verfolgte das Ziel, nur die Position und den
 Sicherheitsbereich anzuzeigen, um nur die wichtigsten Informationen darzustelle
n.
 Der Sicherheitsbereich war jedoch meisten relativ klein im Vergleich zu
 dem Maßstab, in welchem die ECDIS sich meistens befindet und somit nicht
 zu sehen.
 Aus diesem Grund wurde auch dieser Ansatz verworfen.
\end_layout

\begin_layout Standard
Am Ende wurde ein Teil der Darstellung des ersten Ansatzes gewählt, welcher
 nur die Eigenposition und das Heading darstellte.
 Dies ist zu erkennen in Abbildung 4.5.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/User/Desktop/Repositorys/Thesis/Thesis/Grafiken/posFixMinimal.svg
	scale 10

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Visualisierung Eigenposition und Heading
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Darstellung zeigt die Eigenposition als grünes Rechteck und das Heading
 anhand einer Linie, welche die Fahrtrichtung indiziert.
 Die Farbe des Rechtecks stellt hierbei die Größe des Sicherheitsbereichs
 dar.
 Wenn der Sicherheitsbereich größer wird und somit die Position ungenauer,
 wird die Farbe gelb oder rot.
 Dadurch ist das Ergebnis auch in dieser kleinen Darstellung bewertbar und
 kontrollierbar durch den Nautiker.
\end_layout

\end_body
\end_document
