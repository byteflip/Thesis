#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style german
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Umsetzung
\end_layout

\begin_layout Section
Ansätze
\end_layout

\begin_layout Subsection
Iterative Closest Point
\end_layout

\begin_layout Standard
-Allgemeine beschreibung
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
prefix "ICP"
symbol "ICP"
description "Iterative Closest Point"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
- Minimierung der Distanz zwischen Punktwolken
\end_layout

\begin_layout Standard
- fixed, moving Cloud
\end_layout

\begin_layout Standard
- Translation und Rotation
\end_layout

\begin_layout Standard
- error metric: distance between points / sum squarred distances
\end_layout

\begin_layout Standard
- Viele Varianten (alle Verlinken)
\end_layout

\begin_layout Standard
- Stärken: schnell und simpel
\end_layout

\begin_layout Standard
- Schwächen: outliers, rotation, noise in Data, hard matching(0 or 1)?
\end_layout

\begin_layout Subsection
Graph-Matching
\end_layout

\begin_layout Standard
-Allgemeine Beschreibung
\end_layout

\begin_layout Standard
- finden von Subgraphen
\end_layout

\begin_layout Standard
- Funktionsweise kurz beschreiben
\end_layout

\begin_layout Standard
- Stärken: schnell und genau
\end_layout

\begin_layout Standard
- Schwächen: outlier können nicht gefunden werden => falsches Ergebnis
\end_layout

\begin_layout Standard
- Grafik? (wenn Platz ist ja)
\end_layout

\begin_layout Subsection
Coherent Point Drift
\end_layout

\begin_layout Standard
-Einleitung passend zu Grundlagen
\end_layout

\begin_layout Standard
- Begründung warum CPD verwendet wurde:
\end_layout

\begin_layout Standard
- outlier erkennen
\end_layout

\begin_layout Standard
- noise Data
\end_layout

\begin_layout Standard
- soft matching(0.0 - 0.5 - 1.0)? => Falsche matchings können besser erkannt
 werden
\end_layout

\begin_layout Standard
- Performanz Vergleich? (Wieder finden im Paper im Vergleich zu ICP)
\end_layout

\begin_layout Section
Implementierung
\end_layout

\begin_layout Subsection
Programmablauf
\end_layout

\begin_layout Standard
Das entstandene Softwaremodul umfasst verschiedene Abläufe, welche zum besseren
 Verständnis im folgenden erläutert werden.
\end_layout

\begin_layout Standard
In Abbildung 3.1??? ist der Ablauf der Software anhand eines Aktivitätsdiagramms
 dargestellt, dieser wird im folgenden genauer erläutert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/User/Desktop/Repositorys/Thesis/Plannung/ProgrammAblauf.png
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Aktivitätsdiagramm des Softwaremoduls 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zuerst werden die benötigten Daten von der Brücke als NMEA-Nachrichten eingelese
n und in Objekte übersetzt.
 Dies geschieht durch einen NMEA-Parser von Raytheon Anschütz, welcher in
 das Modul eingebunden ist.
\end_layout

\begin_layout Standard
Im folgenden wird ein Algorithmus ausgewählt, welcher passend zu den verfügbaren
 Daten den weiteren Ablauf bestimmt.
 Die hierfür geprüften Daten sind:
\end_layout

\begin_layout Enumerate
AIS Daten umliegender Schiffe und ATONs
\end_layout

\begin_layout Enumerate
Die Geschwindigkeit des eigenen Schiffes
\end_layout

\begin_layout Enumerate
Empfangene AIS-Daten von mindestens drei ATONs
\begin_inset Newline newline
\end_inset

Anhand dieser Daten wird ein Algorithmus ausgewählt, welcher in der jeweiligen
 Situation das beste Ergebnis erzielt.
\end_layout

\begin_layout Standard
Der vorher bestimmte Algorithmus gibt nun an welche der drei Filter auf
 die Daten angewendet werden müssen, um die für den Algorithmus relevanten
 Daten zu extrahieren.
 Diese drei sind: das filtern nach den neuesten AIS und ARPA Daten der Schiffe,
 das filtern nach den ATONs im AIS und das filtern nach ARPA Daten, welche
 keine Geschwindigkeit aufweisen.
\begin_inset Newline newline
\end_inset

Zusätzlich zu diesen drei Filtern werden die AIS-Daten mithilfe von Seekarten
 Informationen abgeglichen.
 Falls ATONs nicht vom AIS erfasst wurden, werden sie nun ergänzt.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Satz vielleicht nochmal umschreiben
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nachdem anwenden der Filter wird der Zeitverzug der AIS-Daten korrigiert.
 Dieser Zeitverzug existiert, da AIS-Nachrichten in einer Frequenz von 3s
 bis 2min gesendet werden können.
 Die Radar Antenne, welche für die ARPA-Daten zuständig ist benötigt jedoch
 für eine volle Umdrehung bzw.
 für das erfassen aller umliegenden Schiffe nur ca.
 2,7s.
 Dieser zeitliche Versatz zwischen den beiden Datensätzen hat einen großen
 Einfluss auf die Genauigkeit der Zuordnung des Algorithmus.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Tabelle hier einfügen und nochmal erklären
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Genauigkeitssteigerung durch Korrektur des Zeitverzugs
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Im folgenden startet der spezifische Algorithmus, die einzelnen Komponenten
 des Algorithmus werden im Laufe der Arbeit genauer behandelt, so wird 
\emph on
AIS zum Koordinaten-Ursprung verschieben
\emph default
 in Unterabschnitt 4.2.2 behandelt und wie das initiale Heading den Algorithmus
 beeinflusst wird in 4.23 erklärt.
\begin_inset Newline newline
\end_inset

Das Ergebnis des Algorithmus ist die Zuordnung zwischen den Punkten und
 der Rotationsunterschied, welcher benötigt wurde um die Punktmengen ineinander
 zu überführen.
 Die Zuordnung wird für den in 4.3 erklärten Position-Fix Algorithmus benötigt
 und die Rotation, welche benötigt wird um beide Punktwolken einander zuzuordnen
 entspricht dem Heading des Eigenschiffes.
 Das Heading auf diese Weise zu bestimmen ist möglich, da die ARPA-Daten
 von der relativen Ausrichtung des Schiffes abhängen, die AIS-Daten jedoch
 nach Norden ausgerichtet sind.
 Somit entspricht eine Drehung der ARPA-Daten, bis sie mit den AIS-Daten
 übereinstimmen, dem Winkel zwischen der Ausrichtung des Schiffe und der
 Himmelsrichtung Norden.
 Dies ist der Winkel, in welchem das Heading eines Schiffes angegeben wird.
\end_layout

\begin_layout Standard
Mit den Ergebnissen des Coherent Point Drift Algorithmus kann nun der Position-F
ix die Eigenposition bestimmen (4.3) und diese als Positionsangabe über eine
 NMEA-Nachricht an die Brücke senden.
 Zusätzlich wird noch eine Visualisierung des Ergebnisses über die von Herrn
 André Becker entwickelte Netzwerkschnittstelle an die ECDIS gesendet.
\end_layout

\begin_layout Subsection
Ungenauigkeiten durch den Erdellipsoid
\end_layout

\begin_layout Standard
Der Coherent Point Drift Algorithmus basiert auf Koordinaten in kartesischer
 Form.
 In dieser Arbeit wurde er, auf WGS 84 Koordinaten angewendet, wodurch einige
 Genauigkeitsprobleme enstanden, die im weiteren erläutert werden und eine
 Lösung für diese präsentiert wird.
\end_layout

\begin_layout Standard
Das erste Problem beruht auf der Translation, welche der Algorithmus anwendet
 um die Distanz zwischen zwei Punktwolken zu minimieren.
 
\begin_inset Newline newline
\end_inset

Die Translation basiert auf dem Unterschied der Punktwolken in 
\begin_inset Formula $x$
\end_inset

 und 
\begin_inset Formula $y$
\end_inset

 Achse.
 Dies ist zwar korrekt in einem kartesischen Koordinatensystem, wo der Abstand
 zwischen zwei Punkten über die Euklidische Norm bestimmt werden kann, jedoch
 nicht wenn mit WGS 84 Koordinaten gearbeitet wird.
 Der Grund hierfür ist, dass der Abstand zwischen den Längengraden zwischen
 Nord- bzw.
 Südpol und dem Äquator sich je nach Position ändern.
 Als Folge hiervon ist es zwar möglich die Punktwolken zueinander zu bewegen,
 jedoch ist die Translation, welche der Algorithmus bestimmt, mit einem
 Fehler versehen.
 Diese Abweichungen die durch dieses Problem entstanden sind verhalten sich
 proportional zum Abstand der beiden Punktwolken (siehe Abbildung/Tabelle
 ???).
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abbildung bzw Tabelle ergänzen
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das zweite Problem entstand durch die Rotation, welche Teil des Algorithmus
 ist.
 Bei einer Rotation werden alle Punkte einer Punktwolke um den Ursprung
 des Koordinatensystems gedreht und erhalten somit eine neue Position.
 Durch das Rotieren einer kartesischen Punktwolke um den Ursprung ändern
 sich die Positionen der Punkte, jedoch nicht die Abstände zwischen den
 Punkten.
 Wenn man WGS 84 Koordinaten rotiert ändern sich ebenso die Positionen der
 Punkte, jedoch ändert sich hier auch der Abstand zwischen den Punkten auf
 Grund der Unterschiedlichen Abstände zwischen Längengraden.
 Die Abweichungen die durch dieses Problem entstanden sind verhalten sich
 proportional zu der Verdrehung zwischen den Punktwolken und proportional
 zum Abstand zwischen Punktwolke und Ursprung.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Proportional? eher exponential oder?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Lösung für das erste Problem (Translation), ist dass minimieren der
 initialen Abstände zwischen den Punktwolken.
 Die Translation die nun benötigt wird für das überführen der einen Punktwolke
 in die andere ist so gering, dass der Fehler der durch die Erdkrümmung
 entsteht vernachlässigbar ist.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Messung im Anhang?
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Die Lösung für das zweit Problem (Rotation) ist, dass verschieben des Schwerpunk
tes der zu rotierenden Punktwolke in den Ursprung des Koordinatensystems.
 Eine Rotation dieser Punktwolke bewirkt nun das der Schwerpunkt seine Position
 nicht verändert, wodurch die Punkte der Punktwolke eine minimale Positionsänder
ung durch eine Rotation erfahren.
\end_layout

\begin_layout Standard
Somit ist die Lösung für diese Probleme die Translation beider Punktwolken
 auf den Ursprung des Koordinatensystems, um so die Ungenauigkeiten so gering
 wie möglich zu halten.
 Dies hat auch den Effekt das Fehler, welche durch das verwenden der euklidische
n Norm auf dem Erdellipsoid entstehen, geringer ausfallen, weil Längen-
 und Breitengrad im Ursprung des Koordinatensystems fast gleich lang sind.
\begin_inset Newline newline
\end_inset

Für die ARPA - Punktwolke ist dies trivial, da aufgrund der Radar Daten
 diese Punkte in Polarkoordinaten angegeben sind, was es leicht macht diese
 zu auf einen bestimmten Punkt zu verschieben.
 
\begin_inset Newline newline
\end_inset

Die AIS - Punktwolke ist jedoch an ihre absolute Position gebunden, deswegen
 ist eine andere Methodik notwendig um die Originale Punktwolke an den Ursprung
 verschieben zu können.
 Hierfür wird der Schwerpunkt der AIS - Punktwolke bestimmt, da diese aus
 nicht gewichteten Punkten besteht ist dieser äquivalent zum arithmetischen
 Mittel der Punktwolke.
 Nun wird die Distanz und der Winkel zwischen jedem Punkt der Punktwolke
 und dem arithmetischem Mittel bestimmt und gespeichert.
 Für die Berechnung der Distanz und der Winkel zwischen den Punkten wird
 die Vincenty Formel verwendet, damit keine Fehler durch die Erdkrümmung
 entstehen.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
inverse oder direct?
\end_layout

\end_inset

 Nun liegt die AIS - Punktwolke in Polarkoordinaten vor.
 Das macht es möglich sie ebenso wie die ARPA - Punktwolke an den Ursprung
 zu platzieren.
 
\end_layout

\begin_layout Standard
Nun sind optimale Bedingungen geschaffen um eine Zuordnung zwischen den
 Punktwolken durch den Coherent Point Drift Algorithmus zu bestimmen.
\end_layout

\begin_layout Subsection
Rotationsschwäche von Coherent Point Drift
\end_layout

\begin_layout Standard
- Experimente beschreiben und Visualisieren (Tabelle oder so) über die Versuche
 bis zu welchem grad die Punktwolke rotiert sein darf (Möglicherweise nicht
 nur für WGS 84 Koordinaten sondern auch für kartesische Koordinaten)
\end_layout

\begin_layout Standard
- Paper verlinken welches dasselbe beobachten konnte
\end_layout

\begin_layout Standard
- Lösung für die Rotation: 
\end_layout

\begin_layout Standard
- Mehrfachausführung mit initialem Drehwinkel für die Arpa Wolke
\end_layout

\begin_layout Standard
- Ergebnis mit dem geringstem Fehler auswählen und zurückgeben (Methodik
 hier genauer beschreiben)
\end_layout

\begin_layout Standard
- Erklärung das es nur einmalig ist, da nach dem ersten Durchlauf wieder
 ein Heading existiert an dem man sich orientieren kann.
\end_layout

\begin_layout Section
Position-Fix
\end_layout

\begin_layout Subsection
Bestimmung der Eigenposition
\end_layout

\begin_layout Standard
Mit dem Ergebnis des Coherent Point Drift Algorithmus können ARPA - Punkte
 auf ihre zugehörigen AIS - Punkte zugeordnet werden.
 Dadurch ist nun bekannt wo dieser Punkt absolut auf der Karte liegt (AIS-Daten)
 und wie er relativ zu der Schiffseigenposition liegt (ARPA-Daten).
 Durch diese beiden Daten ist es möglich die Schiffseigenposition für jedes
 Paar zugeordneter Punkte zu berechnen.
\begin_inset Newline newline
\end_inset

Damit diese Rückrechnung auf die Eigenposition möglich ist, muss zuerst
 das relative Bearing aus den ARPA - Daten in 
\emph on
True 
\emph default
Bearing umgerechnet werden.
 Als 
\emph on
True
\emph default
 Bearing wird das Bearing bezeichnet, welches relativ zur Nord-Richtung
 angegeben wird.
 Diese Umrechnung ist möglich, da der CPD-Algorithmus auch das Heading des
 Schiffes bestimmt 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Wird das im Programmablauf klar?
\end_layout

\end_inset

.
 Das Heading des Schiffes ist relativ zur Nord-Richtung und bietet somit
 die Möglichkeit über folgende Formel eine relative Bearing Angabe in 
\emph on
True 
\emph default
Bearing umzurechnen:
\end_layout

\begin_layout Standard
\begin_inset Formula $b_{true}:$
\end_inset

 
\emph on
True 
\emph default
Bearing
\end_layout

\begin_layout Standard
\begin_inset Formula $b_{rel}:$
\end_inset

 Relatives Bearing
\end_layout

\begin_layout Standard
\begin_inset Formula $h:$
\end_inset

 Heading des Eigenschiffes
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
b_{true} & = & (b_{rel}-h)\quad mod\:360
\end{eqnarray*}

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Formel nochmal checken
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
- Matches aus den Daten erstellen (Zuordnung verwenden und True bearing
 bestimmen)
\end_layout

\begin_layout Standard
- Zurückrechnen der Eigenpositionen
\end_layout

\begin_layout Standard
- Berechnung gewichteter und arithmetischer Mittelwert
\end_layout

\begin_layout Standard
- Grafik für die Mittelwerte um die Auswirkung beschreiben zu können.
\end_layout

\begin_layout Subsection
Bestimmung der Sicherheit der Eigenposition und Eliminierung von Ausreißern
\end_layout

\begin_layout Standard
Bestimmung der Mahalanobis IDstanz von einem Punkt zum Rest als relative
 Abstandsmetrik
\end_layout

\begin_layout Standard
- für jeden Punkt wiederholen und speichern
\end_layout

\begin_layout Standard
- mit % Wert abgleichen und entfernen falls er zu weit von der Punktwolke
 entfernt ist
\end_layout

\begin_layout Standard
- Sicherheitsbereich über Standardabweichung bestimmen
\end_layout

\begin_layout Standard
- Grafik aus der EMS Demo einfügen
\end_layout

\begin_layout Subsection
Erstellung des Ergebnisses
\end_layout

\begin_layout Standard
Kurze Erklärung wie das Ergebniss erstellt wird (NMEA Telegram und Grafik)
 um von der Netzwerkschnittstelle gesendet werden zu können.
\end_layout

\end_body
\end_document
