#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style german
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Umsetzung
\end_layout

\begin_layout Section
Ansätze
\end_layout

\begin_layout Standard
Im folgenden Abschnitt werden verschiedene Ansätze behandelt, welche im
 Laufe der Arbeit evaluiert wurden.
 Alle diese Ansätze basieren auf dem Prinzip einer rigid Registration, da
 sich die Abstände zwischen Punkten nicht ändern dürfen, weil dies eine
 Verfälschung der Schiffsposition wäre.
 Im weiteren werden die Stärken und Schwächen der Ansätze betrachtet und
 mit dem ausgewählten Algorithmus verglichen.
\end_layout

\begin_layout Subsection
Iterative Closest Point
\end_layout

\begin_layout Standard
Der 
\emph on
Iterative Closest Point
\emph default
 Algorithmus (ICP) ist ein sehr bekannter und verbreiteter Algorithmus für
 
\emph on
Rigid Registration
\emph default
.
 Er ist einer der ersten Point Set Registration Verfahren und wurde sehr
 oft mit verschiedenen Methoden erweitert.
 Der normale und unveränderte ICP funktioniert wie folgt: 
\end_layout

\begin_layout Standard
Zuerst werden die Transformationsparameter so initialisiert, dass die beiden
 Punktwolken keine zu großen Unterschiede aufweisen, da sonst eine falsche
 Zuordnung für die Punkte resultieren können.
 Danach werden die Transformationsparameter (Rotation, Translation) auf
 eine Punktwolke angewandt, sodass nun für jeden Punkt aus der transformierten
 Punktwolke der dichteste Punkt aus der fixen Punktwolke bestimmt werden
 kann.
 Dies ist die Zuordnung, welche der Algorithmus bestimmt.
 Wenn die Zuordnung bestimmt wurde, kann nun über die Summe der Abstandsquadrate
 zwischen den Punkten ein Fehler zwischen den Punktwolken berechnet werden.
 Ist dieser Fehler klein genug ist die Registrierung abgeschlossen, ist
 er zu groß werden die Transformationsparameter anhand der gefundenen Zuordnung
 neu bestimmt und der Algorithmus wird iterativ wiederholt, bis er konvergiert.
\begin_inset Newline newline
\end_inset

ICP existiert schon sehr lange, deswegen gibt es eine Vielzahl von Erweiterungen
, wie z.B.
 EM-ICP, welches ICP durch den EM-Algorithmus erweitert.
 So existieren auch Varianten die ICP beschleunigen usw.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hier die aus den Quellen beschreiben
\end_layout

\end_inset

 
\begin_inset Newline newline
\end_inset

Der ICP Algorithmus ist auf Grund seiner einfachen Funktionsweise sehr performan
t und leicht zu verstehen.
 Außerdem lässt er sich wegen seines modularen Aufbaus sehr gut erweitern
 und verändern, was ihn gut anpassbar für viele Situationen macht.
 Er hat jedoch auch einige Nachteile, diese werden im folgenden erläutert.
 
\end_layout

\begin_layout Standard
Die Punktwolken müssen initial bereits annähernd zueinander passen, da sonst
 nicht die optimale Lösung bestimmt werden kann.
 Außerdem sorgen fehlende Punkte in einer der Punktwolken für Probleme,
 da diese die Zuordnung verfälschen können und somit den berechneten Fehler.
\begin_inset Newline newline
\end_inset

Der ICP Algorithmus wurde aus folgenden Gründen nicht in dieser Arbeit verwendet
:
\end_layout

\begin_layout Enumerate
Die Rotation zwischen den beiden Punktwolken kann beliebig sein und ist
 vorher nicht bestimmbar
\end_layout

\begin_layout Enumerate
Es können mehrere Punkte in den Punktwolken fehlen, da diese recht viele
 Punkte enthalten können
\end_layout

\begin_layout Enumerate
Die Zuordnung von Punkten ist eindeutig (0 oder 1), was das erkennen von
 Fehlern oder das bestimmen einer Vertrauenswürdigkeit sehr schwer macht
\end_layout

\begin_layout Subsection
Subgraph Matching
\end_layout

\begin_layout Standard
Das Subgraph Matching ist ein weiterer Ansatz, um eine Zuordnung zwischen
 den Punktwolken wiederherzustellen.
 Hierfür würden die Punktwolken als zwei vollvermaschte Graphen betrachtet
 werden.
 
\begin_inset Newline newline
\end_inset

Das Subgraph Matching auch Sub-Graph Isomorphismus Problem genannt basiert
 auf zwei gegebenen Graphen 
\begin_inset Formula $G$
\end_inset

 und 
\begin_inset Formula $H$
\end_inset

, wobei gezeigt werden soll das 
\begin_inset Formula $G$
\end_inset

 einen Subgraph isomorph zu 
\begin_inset Formula $H$
\end_inset

 enthält.
 Die Eigenschaft isomorph bedeutet das eine Bijektion zwischen den Kanten
 von 
\begin_inset Formula $G$
\end_inset

 und 
\begin_inset Formula $H$
\end_inset

 existiert, sodass zwei benachbarte Kanten in 
\begin_inset Formula $G$
\end_inset

 auch in 
\begin_inset Formula $H$
\end_inset

 benachbarten Kanten entsprechen.
 Für dieses Problem existieren bereits Algorithmen, welche es für große
 Graphen lösen können.[Cordello 2004] [Bonnici 2013]
\begin_inset Newline newline
\end_inset

Die Stärke dieses Ansatzes ist die Genauigkeit, da das finden eines Subgraphen
 eine eindeutige Zuordnung zur Folge hätte, welche je nach Größe des Subgraphs
 auch als dementsprechend sicher einzustufen wäre.
 Zusätzlich kann sich so jede beliebige Rotation zwischen den Punktwolken
 finden lassen, da die Zuordnung nur auf den Abständen zwischen den Punkten
 basiert.
\begin_inset Newline newline
\end_inset

Der Ansatz hat im Kontext dieser Arbeit eine Schwäche, diese ist das fehlende
 Erkennen von Ausreißern.
\begin_inset Newline newline
\end_inset

Das Graph Matching kann mit Ausreißern nicht arbeiten, da es nicht fehlende
 Punkte erkennen kann und ein vollvermaschter Graph sich zusätzlich negativ
 auf die Laufzeit auswirkt.
 Die Ausreißer bei diesem Problem können in AIS- sowie ARPA-Punktwolken
 existieren.
 In der AIS-Punktwolke existieren mehr Punkte als in der ARPA-Punktwolke,
 weil AIS mehr Reichweite als das Radar hat und AIS geographisch nicht durch
 verschiedenen Höhen beschränkt.
\begin_inset Newline newline
\end_inset

Außerdem kann die ARPA-Punktwolke auch Punkte enthalten die in der AIS-Punktwolk
e fehlen.
 Dies ist möglich falls ein Schiff kein AIS sendet oder Radarschatten fälschlich
 für Schiffe gehalten werden.
 Zusätzlich ist der Ansatz sehr Laufzeit intensiv, da die beiden Graphen
 zuerst erstellt werden müssen, wofür die Distanz zwischen allen Punkten
 berechnet werden muss.
 Hierbei würden weitere Probleme entstehen falls gleiche Distanzen mehrfach
 auftreten bzw.
 wie diese gleichen Distanzen auseinander gehalten werden könnten.
\end_layout

\begin_layout Subsection
Coherent Point Drift
\end_layout

\begin_layout Standard
Der in dieser Arbeit verwendete Algorithmus ist der Coherent Point Drift
 Algorithmus.
 Die Wahl für diesen Algorithmus wird im folgenden genauer erklärt.
\end_layout

\begin_layout Standard
Der CPD kann mit verrauschten und Ausreißer behafteten Daten immer noch
 eine korrekte Zuordnung finden.
 Er hat eine 
\emph on
weiche 
\emph default
Zuordnung (Wert zwischen 0 und 1), anstatt einer eindeutigen Zuordnung wie
 der ICP Algorithmus.
 Durch diese 
\emph on
weiche
\emph default
 Zuordnung ist es auch möglich eine Aussage über die Vertrauenswürdigkeit
 eines Zuordnungspaares zu treffen.
 Somit können Punkte, welche sicher zugeordnet werden konnten eine hohe
 Vertrauenswürdigkeit zusprechen, da eine hohe Zuordnung bedeutet, dass
 die ARPA und AIS-Daten zusammenpassten.
 Dadurch könnte der errechnete Wert wie genau die Zuordnung gepasst hat,
 als Gewichtung genutzt werden.
\begin_inset Newline newline
\end_inset

Eine weitere wichtige Eigenschaft von CPD ist, dass es möglich ist Ausreißer
 in den Punktwolken zu erkennen und diese keinem Punkt zuzuordnen.
 Dies war in ICP und Subgraph Matching noch ein Problem.
\begin_inset Newline newline
\end_inset

Zusätzlich kann der CPD auch eine Rotation der Punktwolke erkennen was essentiel
l für die Bestimmung des Headings des Schiffes ist (siehe Programmablauf).
 Dies funktioniert jedoch nur für einen bestimmten Bereich, da der CPD nur
 ein lokales Maximum finden kann.
 Auf dieses Problem wird in 4.23 genauer eingegangen
\begin_inset Newline newline
\end_inset

Es existiert noch ein weitere Problem mit diesem Ansatz.
 Der CPD benötigt für das finden von Ausreißern eine initialen Wert wie
 viele Ausreißer die Punktwolken enthalten werden.
 Die führte aber in Tests mit dem Datengenerator nur in extrem Fällen zu
 falschen Zuordnungen.
 Extrem Fälle bedeutet hierbei der Algorithmus wurde mit 10% Ausreißern
 initialisiert und es sind über 30% aufgetreten.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Zahlen anpassen nach den Bewertungsmessungen
\end_layout

\end_inset

 Diese Schwäche sollte jedoch für Fehlerfälle bedacht werden.
 
\begin_inset Newline newline
\end_inset

In der folgenden Tabelle 1.1???? ist die Entscheidungsfindung für das Verfahren
 tabelliert anhand der Anforderungen.
 Zu erkennen sind die einzelnen Stärken der Ansätze und welche Eigenschaften
 fehlen, um das hier betrachtete Problem effektiv zu lösen.
 GRAFIK STATT TABELLE?
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ICP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Subgraph Matching
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CPD
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rauschen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ja
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nein
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ja
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rotation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nein
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ja
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
teilweise
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ausreißer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nein
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
teilweise (nur wenige)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ja
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
weiches Matching
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nein
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nein
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ja
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Vor- und Nachteile der Ansätze
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Implementierung des CPD Algorithmus erfolgte mithilfe eines Github Repositor
ys.[GITHUB] In diesem ist der Algorithmus mithilfe der Eigen3 Bibliothek
 implementiert wurden.
 Die Eigen3 Bibliothek umfasst Methoden für Matrizen Berechnung, sowie Methoden
 zur Singulärwertzerlegung.
 Diese Implementierung kann auf bestimmte Weise parametrisiert werden, was
 im folgenden genauer erklärt wird.
\end_layout

\begin_layout Standard
Der Algorithmus gibt die Möglichkeit vor der Ausführung mehrere Einstellungen
 zu treffen.
 Hier wurden folgende Einstellungen getroffen:
\end_layout

\begin_layout Enumerate
Spiegelung wurde als Transformation ausgeschlossen
\end_layout

\begin_layout Enumerate
Skalierung wurde als Transformation ausgeschlossen
\end_layout

\begin_layout Enumerate
Die Ausgabe der Zuordnung der Punkte wurde als Rückgabe festgelegt.
\end_layout

\begin_layout Standard
Die Transformationen Spiegelung und Skalierung wurden ausgeschlossen, weil
 dadurch die Punktwolke in ihrer Form verändert werden würde.
 Das ist nicht gewünscht, da die Radardaten sehr genau sind und eine Veränderung
 ihrer Struktur nur zu Fehlern führen würde.
 Zusätzlich würde so auch die Aussagekraft verringert werden, welche die
 Zuordnungswerte haben, falls die Struktur der Punktwolke sich beim Verfahren
 ändert.
\end_layout

\begin_layout Section
Implementierung
\end_layout

\begin_layout Subsection
Programmablauf
\end_layout

\begin_layout Standard
Das entstandene Softwaremodul umfasst verschiedene Abläufe, welche zum besseren
 Verständnis erläutert werden.
\end_layout

\begin_layout Standard
In Abbildung 4.1 ist der Ablauf der Software anhand eines Aktivitätsdiagramms
 dargestellt, dieser wird im folgenden genauer erläutert.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/User/Desktop/Repositorys/Thesis/Thesis/Grafiken/ProgrammAblauf.png
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Aktivitätsdiagramm des Softwaremoduls 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zuerst werden die benötigten Daten von der Brücke als NMEA-Nachrichten eingelese
n.
 Dies geschieht durch einen NMEA-Parser von Raytheon Anschütz, welcher in
 das Modul eingebunden ist.
\end_layout

\begin_layout Standard
Im folgenden wird ein Algorithmus ausgewählt, welcher passend zu den verfügbaren
 Daten den weiteren Ablauf bestimmt.
 Die folgenden Daten werden hier auf ihre Existenz geprüft:
\end_layout

\begin_layout Enumerate
AIS Daten umliegender Schiffe und AtoNs
\end_layout

\begin_layout Enumerate
Die Geschwindigkeit des eigenen Schiffes
\end_layout

\begin_layout Enumerate
Empfangene AIS-Daten von mindestens drei AtoNs
\end_layout

\begin_layout Standard
Anhand dieser Daten wird ein Algorithmus ausgewählt, welcher in der jeweiligen
 Situation das beste Ergebnis erzielt.
\end_layout

\begin_layout Standard
Der bestimmte Algorithmus gibt an, welche der drei Filter auf die Daten
 angewendet werden müssen, um die für den Algorithmus relevanten Daten zu
 extrahieren.
 Diese drei sind: das filtern nach den neuesten AIS und ARPA Daten der Schiffe,
 das filtern nach den AtoNs im AIS und das filtern nach ARPA Daten, welche
 keine Geschwindigkeit aufweisen.
\begin_inset Newline newline
\end_inset

Zusätzlich zu diesen drei Filtern werden die AIS-Daten mithilfe von Seekarten
 Informationen abgeglichen.
 Bei diesem Abgleich werden fehlende AtoNs im AIS durch die Informationen
 der Seekarte ergänzt.
 Dies ist möglich, da alle AtoNs in der Seekarte verzeichnet sind.
 
\end_layout

\begin_layout Standard
Nach der Anwendung der Filter auf die Daten, wird der Zeitverzug der AIS-Daten
 korrigiert.
 Dieser Zeitverzug existiert, da AIS-Nachrichten in einer Frequenz zwischen
 3s bis 2min gesendet werden können.
 Die Sendezeit ist abhängig von der Geschwindigkeit und der Kursänderung
 des Schiffes.
 Die Radar Antenne, welche für die ARPA-Daten zuständig ist benötigt jedoch
 für eine volle Umdrehung bzw.
 für das erfassen aller umliegenden Schiffe nur ca.
 2s bis 4s.
 Dieser zeitliche Versatz zwischen den beiden Datensätzen hat einen großen
 Einfluss auf die Genauigkeit der Zuordnung des Algorithmus.
 
\end_layout

\begin_layout Standard
Im folgenden startet der spezifische Algorithmus, die einzelnen Komponenten
 des Algorithmus werden im Laufe der Arbeit genauer behandelt, so wird 
\emph on
AIS zum Koordinaten-Ursprung verschieben
\emph default
 in Unterabschnitt 4.2.2 behandelt und wie das initiale Heading den Algorithmus
 beeinflusst wird in 4.23 erklärt.
 
\begin_inset Newline newline
\end_inset

Nachdem alle Methoden zur Reduzierung von Ungenauigkeiten ausgeführt wurden
 müssen die ARPA-Daten, welche in Polarkoordinaten vorliegen in geodätische
 Koordinaten umgewandelt werden.
 Hierfür wird ein Punkt gewählt und die Punktwolke von diesem aus konstruiert.
 Wie dieser Punkt optimaler Weise gewählt werden muss ist in 4.22 beschrieben.
\begin_inset Newline newline
\end_inset

Nun kann der CPD mit den beiden Punktwolken als Parameter gestartet werden
 und liefert ein Ergebnis.
 Das Ergebnis des Algorithmus ist die Zuordnung zwischen den Punkten und
 der Rotationsunterschied, welcher benötigt wurde um die Punktwolken ineinander
 zu überführen.
 Die Zuordnung wird für den in 4.3 erklärten Position-Fix Algorithmus benötigt
 und die bestimmte Rotation entspricht dem Heading des Eigenschiffes.
 Die Bestimmung des Headings auf diese Weise ist möglich, da die ARPA-Daten
 von der relativen Ausrichtung des Schiffes abhängen, die AIS-Daten jedoch
 nach Norden ausgerichtet sind.
 Somit entspricht eine Drehung der ARPA-Punktwolke, bis sie mit der AIS-Punktwol
ke übereinstimmen, dem Winkel zwischen der Ausrichtung des Schiffe und der
 Himmelsrichtung Norden.
 Dies ist der Winkel, in welchem das Heading eines Schiffes angegeben wird.
 Eine genaue Berechnung hierzu ist in Abschnitt 4.31 zu finden.
\end_layout

\begin_layout Standard
Mit der Zuordnung der Daten kann nun der Position-Fix die Eigenposition
 bestimmen (4.3) und diese als Positionsangabe über eine NMEA-Nachricht an
 die Brücke senden.
 Zusätzlich wird eine Visualisierung des Ergebnisses über die von Herrn
 André Becker entwickelte Netzwerkschnittstelle an die ECDIS gesendet.
\end_layout

\begin_layout Subsection
Ungenauigkeiten durch den Erdellipsoid
\end_layout

\begin_layout Standard
Der Coherent Point Drift Algorithmus basiert auf Koordinaten in kartesischer
 Form.
 In dieser Arbeit wurde dieser auf geodätische Koordinaten angewendet.
 Wodurch einige Genauigkeitsprobleme entstanden sind, die im weiteren erläutert
 werden und eine Lösung präsentiert wird.
\end_layout

\begin_layout Standard
Das erste Problem beruht auf der Translation, welche der Algorithmus anwendet
 um die Distanz zwischen zwei Punktwolken zu minimieren.
 
\begin_inset Newline newline
\end_inset

Die Translation basiert auf dem Unterschied der Punktwolken in 
\begin_inset Formula $x$
\end_inset

 und 
\begin_inset Formula $y$
\end_inset

 Achse.
 Dies ist zwar korrekt in einem kartesischen Koordinatensystem, wo der Abstand
 zwischen zwei Punkten über die Euklidische Norm bestimmt werden kann, jedoch
 nicht wenn mit geodätische Koordinaten gearbeitet wird.
 Der Grund hierfür ist, dass der Abstand zwischen den Längengraden zwischen
 Nord- bzw.
 Südpol und dem Äquator sich je nach Position ändern.
 Als Folge hiervon ist es zwar möglich die Punktwolken zueinander zu bewegen,
 jedoch ist die Translation, welche der Algorithmus bestimmt, mit einem
 Fehler versehen.
 Diese Abweichungen die durch dieses Problem entstanden sind verhalten sich
 proportional zum Abstand der beiden Punktwolken.
 Der Abstand zwischen den Punktwolken kann beliebig groß sein, da die ARPA-Punkt
wolke ohne eine absolute Positionsangabe in Polarkoordinaten vorliegt und
 somit eine initial Position benötigt wird um aus dieser geodätische Koordinaten
 zu erstellen.
 
\end_layout

\begin_layout Standard
Das zweite Problem entstand durch die Rotation, welche Teil des Algorithmus
 ist.
 Bei einer Rotation werden alle Punkte einer Punktwolke um den Ursprung
 des Koordinatensystems gedreht und erhalten somit eine neue Position.
 Durch das Rotieren einer kartesischen Punktwolke um den Ursprung ändern
 sich die Positionen der Punkte, jedoch nicht die Abstände zwischen den
 Punkten.
 Wenn man geodätische Koordinaten rotiert ändern sich ebenso die Positionen
 der Punkte, jedoch ändert sich hier auch der Abstand zwischen den Punkten
 auf Grund der Unterschiedlichen Abstände zwischen Längengraden.
 Die Abweichungen die durch dieses Problem entstanden sind, steigen mit
 dem Abstand zwischen den Punktwolken.
\end_layout

\begin_layout Standard
Die Lösung für das erste Problem (Translation), ist dass minimieren der
 initialen Abstände zwischen den Punktwolken.
 Die Translation die nun benötigt wird für das überführen der einen Punktwolke
 in die andere resultiert in einer kleinen Abweichung.
\begin_inset Newline newline
\end_inset

Die Lösung für das zweite Problem (Rotation) ist, dass verschieben des Schwerpun
ktes der zu rotierenden Punktwolke in den Ursprung des Koordinatensystems.
 Eine Rotation dieser Punktwolke bewirkt nun das der Schwerpunkt seine Position
 nicht verändert, wodurch die Punkte der Punktwolke eine minimale Positionsänder
ung durch eine Rotation erfahren.
\end_layout

\begin_layout Standard
Somit ist die Lösung für diese Probleme die Translation beider Punktwolken
 auf den Ursprung des Koordinatensystems, um so die Ungenauigkeiten so gering
 wie möglich zu halten.
 Dies hat auch den Effekt das Fehler, welche durch das verwenden der euklidische
n Norm auf dem Erdellipsoid entstehen, geringer ausfallen, weil Längen-
 und Breitengrad im Ursprung des Koordinatensystems fast gleich lang sind.
\begin_inset Newline newline
\end_inset

Für die ARPA - Punktwolke ist dies trivial, da aufgrund der Radar Daten
 diese Punkte in Polarkoordinaten angegeben sind.
 
\begin_inset Newline newline
\end_inset

Die AIS - Punktwolke ist jedoch an ihre absolute Position gebunden, deswegen
 ist eine andere Methodik notwendig, um die Punktwolke, ohne Änderung der
 Abstände zwischen den Punkten, verschieben zu können.
 Die Methodik sieht das bestimmen des Schwerpunktes vor, zu welchem die
 Abstände und der Richtungswinkel von jedem Punkt bestimmt wird.
 Nun kann dieser Punkt in verschoben werden und mithilfe der Abstände und
 Richtungswinkel, lässt sich die Punktwolke korrekt wiederherstellen.
 Der zu bestimmende Punkt ist der Schwerpunkt der AIS-Punktwolke, welcher
 sich über das arithmetische Mittel bestimmen lässt, solange es sich um
 eine nicht gewichtete Punktwolke handelt.
 Nun wird die Distanz und der Winkel zwischen jedem Punkt der Punktwolke
 und dem Schwerpunkt der Wolke bestimmt und gespeichert.
 Für die Berechnung der Distanz und der Winkel zwischen den Punkten wird
 die Vincenty Formel verwendet, damit keine Fehler durch die Erdkrümmung
 entstehen.
 Nun liegt die AIS-Punktwolke theoretisch in Polarkoordinaten vor.
 Das macht es möglich sie ebenso wie die ARPA - Punktwolke an den Ursprung
 zu platzieren.
 
\end_layout

\begin_layout Standard
Nun sind optimale Bedingungen geschaffen um eine Zuordnung zwischen den
 Punktwolken durch den Coherent Point Drift Algorithmus zu bestimmen.
\end_layout

\begin_layout Subsection
Rotationsschwäche von Coherent Point Drift
\end_layout

\begin_layout Standard
Das erkennen von Rotation ist eine essentielle Eigenschaft, welche der Algorithm
us benötigt um die Punktwolken einander zuzuordnen und somit auch das Heading
 des Eigenschiffes zu bestimmen.
 Die Rotation kann jeden beliebigem gültigen Wert entsprechen, da die Drehung
 der ARPA Punktwolke abhängig vom Heading ist und die Drehung der AIS Punktwolke
 immer nach Norden ausgerichtet ist.
 Somit ist jeder Rotationswinkel eine mögliche Lösung und das Problem kann
 nicht vorher behandelt werden.
\end_layout

\begin_layout Standard
Der CPD kann nur ein lokales Minima finden, da er auf dem EM-Algorithmus
 basiert.
 Die erkennbare Rotation ist nach NACHNAME bei ca.
 
\begin_inset Formula $65°$
\end_inset

[QUELLE].
 Bei Punktwolken, welche mehr als 
\begin_inset Formula $65°$
\end_inset

 Rotationsunterschied besitzen, findet der Algorithmus möglicherweise nur
 ein lokales Minima.
 Ein hierzu ausgeführter Versuch mit perfekten Daten beweist diese These
 (Tabelle 4.3).
\begin_inset Newline newline
\end_inset

In Tabelle 4.3??? wurden die Ergebnisse des CPD Algorithmus für verschiedene
 Rotationen bestimmt.
 Diese Messung wurde mit perfekten Daten ausgeführt, dass bedeutet das alle
 Punkte zugeordnet werden können, die Punkte perfekt aufeinander passen
 und das lediglich der Rotationswinkel der Punktwolken sie voneinander untersche
idet.
 Die Punkte der Punktwolke wurden zufällig anhand einer Normalverteilung
 erstellt und besteht aus 20 Punkten in geodätischen Koordinaten.
 Alle Angaben sind in Grad gegeben.
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rotationswinkel (°)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gefundenes Minima (°)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 - 70
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
80 - 140
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150 - 160
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
172
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
170 - 220
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
230
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
230 - 300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
282
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
310 - 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Bestimmte Rotation durch CPD an perfekten Daten
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es ist deutlich zu erkennen, dass der CPD Algorithmus ab einem bestimmten
 Rotationswinkel, die korrekte Rotation nicht mehr findet und in einem lokalen
 Minimum terminiert.
 In den Testdaten von Tabelle 4.3??? werden fünf verschiedene Minima gefunden,
 je nach Rotation der Punktwolke.
 
\end_layout

\begin_layout Standard
Für dieses Problem wurde eine Lösung entwickelt, um die korrekte Rotation,
 sowie die korrekte Zuordnung zu bestimmen.
 
\begin_inset Newline newline
\end_inset

Hierfür wird der Algorithmus mehrfach ausgeführt, wobei nach jeder Ausführung
 die ARPA-Punktwolke rotiert wird und die Ergebnisse gespeichert werden.
 Für die kontinuierliche Rotation wurden 
\begin_inset Formula $45°$
\end_inset

 gewählt.
 Es wurden 
\begin_inset Formula $45°$
\end_inset

 gewählt anstatt den gemessenen 
\begin_inset Formula $65°$
\end_inset

, weil diese Messung ohne Ausreißer stattfand und außerdem noch weitere
 Abweichungen das Ergebnis beeinflussen können.
 Eine dieser zu beachtenden Abweichungen ist das Euklidische Transformationen
 auf geodätische Daten angewandt werden, was in Abweichungen resultieren
 könnte.
 Die Rotation der ARPA-Punktwolke ist sehr simple, da sie bereits in Polarkoordi
naten vorliegt.
 Nachdem der Algorithmus 8 mal ausgeführt wurde (
\begin_inset Formula $\frac{360}{45}=8$
\end_inset

) werden die Ergebnisse verglichen.
 Hierbei wird das Ergebnis mit dem geringsten Fehler zwischen den Punkten
 ausgewählt, da so das globale Optimum gefunden wird.
\begin_inset Newline newline
\end_inset

Diese Lösung hat natürlich einen großen Nachteil, welcher die Performanz
 des Algorithmus ist.
 Der Algorithmus muss acht mal gestartet werden um ein korrektes Ergebnis
 zu produzieren.
 Die achtfache Ausführung ist jedoch nur beim initialen Ausführen des Softwaremo
duls nötig, weil nach dem ersten Durchlauf des Softwaremoduls ein Heading
 an die Brücke gesendet wird, welches beim nächsten Aufrufen des Algorithmus
 mit gesendet wird und somit ein initiales Heading existiert.
 Wenn ein Heading mit gesendet wird muss der Algorithmus nur einmal ausgeführt
 werden, weil die ARPA-Punktwolke nur um den Wert des negativen Headings
 gedreht werden muss und dadurch die Punktwolken eine Ähnliche Rotation
 aufweisen sollten.
\end_layout

\begin_layout Section
Position-Fix
\end_layout

\begin_layout Standard
Der folgenden Abschnitt beschreibt die Berechnung der Eigenposition und
 des Sicherheitsbereichs, welche aus der Zuordnung und dem bestimmten Heading
 des CPD möglich ist.
\end_layout

\begin_layout Subsection
Bestimmung der Eigenposition
\end_layout

\begin_layout Standard
Mit dem Ergebnis des Coherent Point Drift Algorithmus können ARPA - Punkte
 auf ihre zugehörigen AIS - Punkte zugeordnet werden.
 Dadurch ist nun bekannt wo dieser Punkt absolut auf der Karte liegt (AIS-Daten)
 und wie er relativ zu der Schiffseigenposition liegt (ARPA-Daten).
 Durch diese beiden Daten ist es möglich die Schiffseigenposition für jedes
 Paar zugeordneter Punkte zu berechnen.
\begin_inset Newline newline
\end_inset

Momentan wird bei versagen der GPS-Analge die Eigenposition von der Besatzung
 des Schiffes bestimmt.
 Hierfür werden markante Ziele im AIS gesucht wie Leuchttürme.
 Danach muss der Nautiker überprüfen in welchem Winkel dieses Ziel zum eigenen
 Schiff liegt und so selber den passenden Radarpunkt identifizieren.
 Dies wird für zwei bis drei Ziele wiederholt womit der Nautiker nun die
 Eigenposition berechnen kann.
 Dies ist sehr aufwendig und soll von dem hier entwickelten Algorithmus
 möglichst ohne manuelle Eingaben umgesetzt werden.
 Dessen Funktionsweise wird im weiteren genauer beschrieben.
\end_layout

\begin_layout Standard
Damit diese Rückrechnung auf die Eigenposition möglich ist, muss zuerst
 das relative Bearing aus den ARPA - Daten in 
\emph on
true 
\emph default
Bearing umgerechnet werden.
 Als 
\emph on
True
\emph default
 Bearing wird das Bearing bezeichnet, welches relativ zur Nord-Richtung
 angegeben wird.
 Diese Umrechnung ist möglich, da der CPD-Algorithmus auch das Heading des
 Schiffes bestimmt.
 Das Heading des Schiffes ist relativ zur Nord-Richtung und bietet somit
 die Möglichkeit über folgende Formel eine relative Bearing Angabe in 
\emph on
True 
\emph default
Bearing umzurechnen:
\end_layout

\begin_layout Standard
\begin_inset Formula $b_{true}:$
\end_inset

 
\emph on
True 
\emph default
Bearing
\end_layout

\begin_layout Standard
\begin_inset Formula $b_{rel}:$
\end_inset

 Relatives Bearing
\end_layout

\begin_layout Standard
\begin_inset Formula $h:$
\end_inset

 Heading des Eigenschiffes
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
b_{true} & = & (b_{rel}-h)\quad mod\:360
\end{eqnarray*}

\end_inset


\begin_inset Newline newline
\end_inset

Nun kann von jedem Datenpaar eine individuelle Eigenposition bestimmt werden.
 Dies basiert auf der Lösung der 1.
 geodätischen Hauptaufgabe, diese ist das berechnen eines Punktes mit einem
 Startpunkt, einer Richtung und einer Distanz.
 Der Startpunkt sind die AIS Koordinaten, die Richtung ist das negierte
 
\emph on
true 
\emph default
Bearing und die Distanz kann aus den ARPA - Daten entnommen werden.
 Die Lösung der 1.
 geodätischen Hauptaufgabe lässt sich mithilfe der Vincenty Formel bestimmen.
 
\begin_inset Newline newline
\end_inset

Nachdem dies für jedes Datenpaar wiederholt wurde, existiert eine Punktwolke,
 welche die individuellen Eigenpositionen enthält.
 Zur Bestimmung der Eigenposition wird das arithmetische Mittel über diese
 Punktwolke gebildet.
 Falls die einzelnen Punkte vorher eine Gewichtung besitzen, was zur Indizierung
 einer höheren Vertrauenswürdigkeit verwendet werden kann, kann hier auch
 das gewichtete arithmetische Mittel angewendet werden.
\begin_inset Newline newline
\end_inset

Die Auswirkung für die Verwendung eines gewichteten Arithmetischen Mittels
 anstatt des normalen arithmetischen Mittels ist in Abbildung 4.2??? zu erkennen.
 In der Abbildung haben die Punkte 6 - 10 eine höhere Gewichtung als die
 Punkte 1 - 4, was dafür sorgt, dass diese beim gewichteten Arithmetischen
 Mittel stärker berücksichtigt werden.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/User/Desktop/Repositorys/Thesis/Thesis/Grafiken/WeightedAndArithmeticMean.PNG

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Arithmetisches Mittel der individuell zurückgerechneten Eigenpositionen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Abbildung zeigt wie stark die Genauigkeit der Positionsbestimmung erhöht
 werden kann, falls es möglich ist eine Aussage über die Genauigkeit oder
 die Vertrauenswürdigkeit der einzelnen Punkte treffen zu können.
 Das wäre möglich über das Unterscheiden von Schiffen und AtoNs oder einer
 manuellen Eingabe.
\end_layout

\begin_layout Subsection
Bestimmung der Sicherheit der Eigenposition und Eliminierung von Ausreißern
\end_layout

\begin_layout Standard
Die Bestimmung der Eigenposition erfolgt über das arithmetische Mittel,
 dieses ist jedoch anfällig für Ausreißer in der Punktwolke.
 Zusätzlich ist es notwendig die bestimmte Eigenposition mit einer Sicherheit
 bzw.
 eines Sicherheitsbereichs angeben zu können.
\end_layout

\begin_layout Standard
Durch die Anfälligkeit des arithmetischen Mittels auf Ausreißer, ist es
 notwendig diese zu bestimmen und in gravierenden Fällen zu eliminieren.
 Dies kann jedoch nur angewendet werden, wenn genügend Punkte in der Punktwolke
 existieren, da sonst Ausreißer nicht eindeutig klassifiziert werden können.
\begin_inset Newline newline
\end_inset

Zur Erkennung der Ausreißer wird die Mahalanobis Distanz verwendet.
 Die Mahalanobis Distanz ist ein Abstandsmaß, welche angibt wie weit ein
 Punkt von der Verteilung einer Punktwolke abweicht.
 Das Ergebnis der Mahalanobis Distanz wird in Standardnormalabweichungen
 angegeben.
 Die Mahalanobis Distanz ist wie folgt definiert: 
\end_layout

\begin_layout Standard
\begin_inset Formula $\vec{X_{i}}=\begin{pmatrix}lat_{i}\\
lon_{i}
\end{pmatrix}:$
\end_inset

 eine Zufallsvariable, welche die zurückgerechnete Position eines Datenpaars
 beschreibt.
 (
\begin_inset Formula $lat$
\end_inset

 ist der Breitengrad und 
\begin_inset Formula $lon$
\end_inset

 der Längengrad des Punktes)
\end_layout

\begin_layout Standard
\begin_inset Formula $\vec{\mu}=\begin{pmatrix}\mu_{lat}\\
\mu_{lon}
\end{pmatrix}:$
\end_inset

 Das arithmetische Mittel der Punktwolke
\end_layout

\begin_layout Standard
\begin_inset Formula $\Sigma:$
\end_inset

 Die Kovarianzmatrix der Punktwolke für welche gilt 
\begin_inset Formula $det(\Sigma)\neq0$
\end_inset


\end_layout

\begin_layout Standard
Mahalanobis-Distanz:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d(\vec{X},\vec{\mu})=\sqrt{(\vec{X}-\vec{\mu})^{T}\cdot\Sigma^{-1}\cdot(\vec{X}-\vec{\mu})}
\]

\end_inset


\begin_inset Newline newline
\end_inset

zur Berechnung der Mahalanobis Distanz wird nun das arithmetische Mittel
 und die Kovarianzmatrix bestimmt, jedoch ohne einbeziehen des Punktes zu
 welchem die Mahalanobis Distanz bestimmt werden soll, da sonst das Ergebnis
 verfälscht wird.
 Nachdem dies für jeden individuelle Eigenposition berechnet wurde ist es
 möglich Punkte zu entfernen, welche außerhalb einer bestimmten Prozentzahl
 der Verteilung liegen.
 Für diese Prozentzahl wurde 
\begin_inset Formula $99,865\%$
\end_inset

 gewählt, das entspricht einem Z-Wert der Standardnormalverteilung von 
\begin_inset Formula $3$
\end_inset

.
 Somit werden Punkte entfernt die Außerhalb von 
\begin_inset Formula $99.865\%$
\end_inset

 der Verteilung liegen.
\begin_inset Newline newline
\end_inset

Nachdem die Ausreißer entfernt wurden ist es wichtig die Genauigkeit des
 Ergebnisses angeben zu können.
 Hierfür wurde sich entschieden einen Sicherheitsbereich zu bestimmen, durch
 welchen eine prozentuale Sicherheit gegeben werden kann, wie wahrscheinlich
 es ist sich in diesem Bereich zu befinden.
 Dieser Sicherheitsbereich wird mithilfe der Mahalanobis Distanz bestimmt.
 Man setzt die Mahalanobis Distanz auf einen festen Wert, wie z.B.
 
\begin_inset Formula $2,33$
\end_inset

 was ca.
 
\begin_inset Formula $99\%$
\end_inset

 Sicherheit entspricht.
 Nun kann durch einsetzen des arithmetischen Mittels und der Kovarianzmatrix
 eine Menge an Punkten bestimmt werden, welche diese Mahalanobis Distanz
 haben.
 Die Form der Punkte entspricht einer Ellipse, welche der Sicherheitsbereich
 ist.
 Eine Visualisierung dieses Ablaufs ist in Abbildung 4.3???? zu erkennen.
 Die roten Punkte sind zurückgerechnete Eigenpositionen, wobei 10 ein Ausreißer
 ist, welcher das Resultat einer falschen Zuordnung sein könnte.
 Die Ellipsen indizieren die Standardabweichungen vom Faktor 1 bis 4 von
 innen nach außen.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Sicherheitsbereich über Standardabweichung? eher schlecht wegen der Abweichung,
 ist aktuell jedoch so im Algorithmus umgesetzt.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/User/Desktop/Repositorys/Thesis/Thesis/Grafiken/OutlierRemoval.PNG
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Eliminierung von Ausreißern und Darstellung des Sicherheitsbereichs
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es ist klar zu erkennen wie groß die Auswirkung eines Ausreißers auf die
 Eigenposition und den Sicherheitsbereich ist.
 Deshalb ist diese Methode zum erkennen und ausschließen des Ausreißers
 sehr wichtig um auch in Fehlerfällen eine sichere und möglichst genaue
 Eigenposition bestimmen zu können.
\end_layout

\begin_layout Subsection
Erstellung des Ergebnisses
\end_layout

\begin_layout Standard
Nach dem Position-Fix Algorithmus wurden alle benötigten Daten berechnet
 um die Eigenposition, das Heading und eine geeignete Visualisierung darzustelle
n.
 Die Eigenposition und das Heading werden als NMEA-Nachricht an die Brücke
 gesendet, da ihre Daten so intern wie die Daten eines Sensors behandelt
 werden und dadurch eine Integritätsprüfung im Vergleich zu den anderen
 Sensoren möglich ist.
 Die Visualisierung und zusätzliche Daten, wie der Sicherheitsbereich, werden
 über die Netzwerkschnittstelle von Herrn André Becker an die ECDIS übermittelt.
 Die Visualisierung ist eine SVG-Grafik, welche beispielhaft in Abbildung
 4.4???
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abbildung
\end_layout

\end_inset

 abgebildet ist.
 KOMMT SPÄTER
\begin_inset Note Note
status open

\begin_layout Plain Layout
Hier Erklärung zu der Visualisierung noch einfügen
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Visualisierung zur Anzeige des Ergebnisses auf der Seekarte
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
